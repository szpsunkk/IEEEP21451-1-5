/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "ieeeP1451Project.h"



#include <Python.h>
#include <stdarg.h>




unsigned char buf[1024];

/* for acceptable `arg_format' `ret_val_format', see https://docs.python.org/2.7/c-api/arg.html */
int int_py_caller(char *python_module_name, char *python_func_name, char *arg_format, char *ret_val_format, ...)
{
  PyObject *python_module_object    = NULL;
  PyObject *python_arg_object   = NULL;
  PyObject *python_func_object    = NULL;
  PyObject *python_return_val_object  = NULL;

  va_list vl; /* this is used to parse the arguments in the `...' part. see stdarg(3) */

  Py_Initialize();

  /* these two lines are required, if any custom module under the current working dirctory is to be loaded */
  PyRun_SimpleString("import sys");
  PyRun_SimpleString("sys.path.append('.')");

  python_module_object = PyImport_ImportModule(python_module_name); 
  if (!python_module_object) {
    printf("Error: cannot import module.\n");
    // return 0; // TODO:
  }

  python_func_object = PyObject_GetAttrString(python_module_object, python_func_name);
  if (!python_func_object) {
    printf("Error: cannot import function.\n");
    // return 0; // TODO:
  }

  /* start parsing arguments */
  va_start(vl, ret_val_format);
  /* construct arguments for the python function using the arguments passed to this C function */
  python_arg_object = Py_VaBuildValue(arg_format, vl);
  if (!python_arg_object) {
    printf("Error: cannot construct arguments.\n");
    // return 0; // TODO:
  }
  /* finish parsing arguments */
  va_end(vl);

  // PyObject_Print(python_arg_object, stdout, 0/*Py_PRINT_RAW*/); /* the 3rd arg controls either using `str()' or `repr()' */
  // printf("\n");


  /* `python_arg_object' should be a tuple */
  python_return_val_object = PyEval_CallObject(python_func_object, python_arg_object);
  if (!python_return_val_object) {
    printf("Error: function not called successfully.\n");
    // return 0; // TODO:
  }

  // TODO: another function? use tuple or not? what if multiple return value?
  // after experiemnt, PyArg_Parse can't use tuple
  if (!PyArg_Parse(python_return_val_object, ret_val_format, buf)) {
    printf("Error: cannot parse return value.\n");
    // return 0; // TODO:
  }

  // TODO: unified way of handling types
  printf("%d\n", *((int *) buf));

  Py_DECREF(python_module_object);
  Py_DECREF(python_func_object);
  Py_DECREF(python_arg_object);
  Py_DECREF(python_return_val_object);

  return *((int *) buf);
}

/* STARTS */

#include  <stdlib.h>
#include  <time.h>

#define   TEMPERATURE_FLUCTUATION   2
#define   LIGHT_FLUCTUATION   4
#define   LCD_STRING_MAX_LEN    10240

long  value_of_temperature;
long  value_of_light;
long  base_value_of_temperature   = 140;
long  base_value_of_light     = 120;
long  gain_value_of_light_when_lamp_on  = 60;
long  status_of_lamp        = 0;
long  status_of_humdifier     = 0;
char  lcd_display_string[LCD_STRING_MAX_LEN]  = "Good morning!";
int lcd_display_string_len      = 13;

long
randl(long max)
{
  return ((long) rand()) % max;
}




/** Initializes the ieeeP1451Project module */
void
init_ieeeP1451Project(void)
{
    const oid seTemperature_oid[] = { 1,3,6,1,4,1,7934,1451,1,1 };
    const oid seHumidity_oid[] = { 1,3,6,1,4,1,7934,1451,1,2 };
    const oid seDistence_oid[] = { 1,3,6,1,4,1,7934,1451,1,3 };
    const oid seAcceleration_oid[] = { 1,3,6,1,4,1,7934,1451,1,4 };
    const oid seHS_oid[] = { 1,3,6,1,4,1,7934,1451,1,5 };
    const oid seSmoker_oid[] = { 1,3,6,1,4,1,7934,1451,1,6 };
    const oid seGravity_oid[] = { 1,3,6,1,4,1,7934,1451,3,7 };
    const oid sePressure_oid[] = { 1,3,6,1,4,1,7934,1451,4,8 };
    const oid acLamp_oid[] = { 1,3,6,1,4,1,7934,1451,4,1 };
    const oid acHumidifier_oid[] = { 1,3,6,1,4,1,7934,1451,4,2 };
    const oid acbuzzer_oid[] = { 1,3,6,1,4,1,7934,1451,4,3 };
    const oid acLEDScreen_oid[] = { 1,3,6,1,4,1,7934,1451,4,4 };

  DEBUGMSGTL(("ieeeP1451Project", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("seTemperature", handle_seTemperature,
                               seTemperature_oid, OID_LENGTH(seTemperature_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("seHumidity", handle_seHumidity,
                               seHumidity_oid, OID_LENGTH(seHumidity_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("seDistence", handle_seDistence,
                               seDistence_oid, OID_LENGTH(seDistence_oid),
                               HANDLER_CAN_RONLY
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("seAcceleration", handle_seAcceleration,
                               seAcceleration_oid, OID_LENGTH(seAcceleration_oid),
                               HANDLER_CAN_RONLY
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("seHS", handle_seHS,
                               seHS_oid, OID_LENGTH(seHS_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("seSmoker", handle_seSmoker,
                               seSmoker_oid, OID_LENGTH(seSmoker_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("seGravity", handle_seGravity,
                               seGravity_oid, OID_LENGTH(seGravity_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("sePressure", handle_sePressure,
                               sePressure_oid, OID_LENGTH(sePressure_oid),
                               HANDLER_CAN_RONLY
        ));







    netsnmp_register_scalar(
        netsnmp_create_handler_registration("acLamp", handle_acLamp,
                               acLamp_oid, OID_LENGTH(acLamp_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("acHumidifier", handle_acHumidifier,
                               acHumidifier_oid, OID_LENGTH(acHumidifier_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("acbuzzer", handle_acbuzzer,
                               acbuzzer_oid, OID_LENGTH(acbuzzer_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("acLEDScreen", handle_acLEDScreen,
                               acLEDScreen_oid, OID_LENGTH(acLEDScreen_oid),
                               HANDLER_CAN_RWRITE
        ));
      srand(time(0));
}

int
handle_seTemperature(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
        value_of_temperature = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 0);

            snmp_set_var_typed_value(requests->requestvb, 
                                    ASN_INTEGER,
                                    &value_of_temperature,
                                     (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_seTemperature\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_seHumidity(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
              value_of_light = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 1);
              // value_of_light = base_value_of_light
              //                + ((long) status_of_lamp) * gain_value_of_light_when_lamp_on
              //                + randl(LIGHT_FLUCTUATION)
              //                - LIGHT_FLUCTUATION / 2;
                      snmp_set_var_typed_value(requests->requestvb,
                                               ASN_INTEGER,
                                               &value_of_light,
                                               (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_seLight\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_seDistence(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
              value_of_light = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 2);
              // value_of_light = base_value_of_light
              //                + ((long) status_of_lamp) * gain_value_of_light_when_lamp_on
              //                + randl(LIGHT_FLUCTUATION)
              //                - LIGHT_FLUCTUATION / 2;
                      snmp_set_var_typed_value(requests->requestvb,
                                               ASN_INTEGER,
                                               &value_of_light,
                                               (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_seLight\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_seAcceleration(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
              value_of_light = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 3);
              // value_of_light = base_value_of_light
              //                + ((long) status_of_lamp) * gain_value_of_light_when_lamp_on
              //                + randl(LIGHT_FLUCTUATION)
              //                - LIGHT_FLUCTUATION / 2;
                      snmp_set_var_typed_value(requests->requestvb,
                                               ASN_INTEGER,
                                               &value_of_light,
                                               (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_seLight\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_seHS(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
              value_of_light = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 4);
              // value_of_light = base_value_of_light
              //                + ((long) status_of_lamp) * gain_value_of_light_when_lamp_on
              //                + randl(LIGHT_FLUCTUATION)
              //                - LIGHT_FLUCTUATION / 2;
                      snmp_set_var_typed_value(requests->requestvb,
                                               ASN_INTEGER,
                                               &value_of_light,
                                               (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_seLight\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_seSmoker(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
              value_of_light = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 5);
              // value_of_light = base_value_of_light
              //                + ((long) status_of_lamp) * gain_value_of_light_when_lamp_on
              //                + randl(LIGHT_FLUCTUATION)
              //                - LIGHT_FLUCTUATION / 2;
                      snmp_set_var_typed_value(requests->requestvb,
                                               ASN_INTEGER,
                                               &value_of_light,
                                               (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_seLight\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_seGravity(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
              value_of_light = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 6);
              // value_of_light = base_value_of_light
              //                + ((long) status_of_lamp) * gain_value_of_light_when_lamp_on
              //                + randl(LIGHT_FLUCTUATION)
              //                - LIGHT_FLUCTUATION / 2;
                      snmp_set_var_typed_value(requests->requestvb,
                                               ASN_INTEGER,
                                               &value_of_light,
                                               (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_seLight\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sePressure(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
              value_of_light = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 7);
              // value_of_light = base_value_of_light
              //                + ((long) status_of_lamp) * gain_value_of_light_when_lamp_on
              //                + randl(LIGHT_FLUCTUATION)
              //                - LIGHT_FLUCTUATION / 2;
                      snmp_set_var_typed_value(requests->requestvb,
                                               ASN_INTEGER,
                                               &value_of_light,
                                               (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_seLight\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}













int
handle_acLamp(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:

            status_of_lamp = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 2);
            snmp_set_var_typed_value(requests->requestvb,
                                     ASN_INTEGER,
                                     &status_of_lamp,
                                     (size_t) 8);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //      XXX malloc "undo" storage buffer 
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
            status_of_lamp = *(requests->requestvb->val.integer);
            if (status_of_lamp)
              status_of_lamp = 1;
            int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 4, status_of_lamp);
            /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_acLamp\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_acHumidifier(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
                      status_of_humdifier = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 3);
                              snmp_set_var_typed_value(requests->requestvb,
                                                       ASN_INTEGER,
                                                       &status_of_humdifier,
                                                       (size_t) 8);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //     /* XXX malloc "undo" storage buffer */
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
            /* STARTS */
            status_of_humdifier = *(requests->requestvb->val.integer);
            if (status_of_humdifier)
              status_of_humdifier = 1;
            int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 5, status_of_humdifier);
            /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_acHumidifier\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_acLcd(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */
    int i;
    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb,
                                     ASN_OCTET_STR,
                                     lcd_display_string,
                                     (size_t) lcd_display_string_len);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //     /* XXX malloc "undo" storage buffer */
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
            /* STARTS */
            if (requests->requestvb->val_len > LCD_STRING_MAX_LEN)
              break;

            lcd_display_string_len = (int) (requests->requestvb->val_len);
            for (i = 0; i < lcd_display_string_len; i++)
              lcd_display_string[i] = requests->requestvb->val.string[i];
            /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_acLcd\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
void
initialize_table_ieeeP1451TimTable(void)
{
    const oid ieeeP1451TimTable_oid[] = {1,3,6,1,4,1,7934,1451,1};
    const size_t ieeeP1451TimTable_oid_len   = OID_LENGTH(ieeeP1451TimTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("ieeeP1451Project3:init", "initializing table ieeeP1451TimTable\n"));

    reg = netsnmp_create_handler_registration(
              "ieeeP1451TimTable",     ieeeP1451TimTable_handler,
              ieeeP1451TimTable_oid, ieeeP1451TimTable_oid_len,
              HANDLER_CAN_RWRITE
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: timid */
                           0);
    table_info->min_column = COLUMN_TIMID;
    table_info->max_column = COLUMN_NEWROWSTATUS;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = ieeeP1451TimTable_get_first_data_point;
    iinfo->get_next_data_point  = ieeeP1451TimTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );
    netsnmp_inject_handler_before( reg, 
        netsnmp_get_cache_handler(IEEEP1451TIMTABLE_TIMEOUT,
                                  ieeeP1451TimTable_load, ieeeP1451TimTable_free,
                                  ieeeP1451TimTable_oid, ieeeP1451TimTable_oid_len),
            TABLE_ITERATOR_NAME);

    /* Initialise the contents of the table here */
}

#define NNN 256

    /* Typical data structure for a row entry */
struct ieeeP1451TimTable_entry {
    /* Index values */
    long timid;

    /* Column values */
    // long timid;
    char newValue[NNN];
    size_t newValue_len;
    long newRowStatus;

    /* Illustrate using a simple linked list */
    int   valid;
    struct ieeeP1451TimTable_entry *next;
};

struct ieeeP1451TimTable_entry  *ieeeP1451TimTable_head;


    /* Typical data structure for a row entry */
struct ieeeP1451ChannelTable_entry {
    /* Index values */
    long timID;
    long channelID;

    /* Column values */
    // long timID;
    // long channelID;
    char commuType[NNN];
    size_t commuType_len;
    char old_commuType[NNN];
    size_t old_commuType_len;
    char commuAddress[NNN];
    size_t commuAddress_len;
    char old_commuAddress[NNN];
    size_t old_commuAddress_len;
    char testValue[NNN];
    size_t testValue_len;
    long p1451RowStatus;

    /* Illustrate using a simple linked list */
    int   valid;
    struct ieeeP1451ChannelTable_entry *next;
};

struct ieeeP1451ChannelTable_entry  *ieeeP1451ChannelTable_head;

/* create a new row in the (unsorted) table */
struct ieeeP1451TimTable_entry *
ieeeP1451TimTable_createEntry(
                 long  timid
                ) {
    struct ieeeP1451TimTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct ieeeP1451TimTable_entry);
    if (!entry)
        return NULL;

    entry->timid = timid;
    entry->next = ieeeP1451TimTable_head;
    ieeeP1451TimTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
ieeeP1451TimTable_removeEntry( struct ieeeP1451TimTable_entry *entry ) {
    struct ieeeP1451TimTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = ieeeP1451TimTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        ieeeP1451TimTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}

#define STRMAX 1024

/* Example cache handling - set up linked list from a suitable file */
int
ieeeP1451TimTable_load( netsnmp_cache *cache, void *vmagic ) {
    FILE *fp;
    struct ieeeP1451TimTable_entry *this;
    char buf[STRMAX];

    /* The basic load routine template assumes that the data to
       be reported is held in a file - with one row of the file
       for each row of the table.
          If your data is available via a different API, you
       should amend this initial block (and the control of the
       'while' loop) accordingly.
          'XXX' marks where the template is incomplete and
       code will definitely need to be added. */

    fp = fopen( "/data/for/ieeeP1451TimTable", "r" );
    if ( !fp ) {
        return -1;
    }
    while ( fgets( buf, STRMAX, fp )) {
        this = SNMP_MALLOC_TYPEDEF( struct ieeeP1451TimTable_entry );
        /* XXX - Unpick 'buf' to extract the individual field values
                 and then populate the 'this' data structure with them */

        this->next = ieeeP1451TimTable_head;
        ieeeP1451TimTable_head = this;    /* Iterate helper is fine with unordered lists! */
    }
    fclose(fp);
    return 0;  /* OK */
}

void
ieeeP1451TimTable_free( netsnmp_cache *cache, void *vmagic ) {
    struct ieeeP1451TimTable_entry *this, *that;

    for ( this = ieeeP1451TimTable_head; this; this=that ) {
        that = this->next;
        SNMP_FREE( this );   /* XXX - release any other internal resources */
    }
    ieeeP1451TimTable_head = NULL;
}

/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
ieeeP1451TimTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = ieeeP1451TimTable_head;
    return ieeeP1451TimTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
ieeeP1451TimTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct ieeeP1451TimTable_entry *entry = (struct ieeeP1451TimTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->timid );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the ieeeP1451TimTable table */
int
ieeeP1451TimTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct ieeeP1451TimTable_entry          *table_entry;
    struct userTable_entry *table_row;
    int ret;

    DEBUGMSGTL(("ieeeP1451Project3:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451TimTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_TIMID:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->timid);
                break;
            case COLUMN_NEWVALUE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                struct ieeeP1451ChannelTable_entry *loopTable = ieeeP1451ChannelTable_head;
                while(loopTable){
                    if(loopTable->timID == table_entry->timid){
                        printf("%ld %ld\n", loopTable->timID, loopTable->channelID);
                    }
                    loopTable = loopTable->next;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->newValue,
                                          table_entry->newValue_len);
                break;
            case COLUMN_NEWROWSTATUS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->newRowStatus);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451TimTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_NEWROWSTATUS:
                ret = netsnmp_check_vb_rowstatus(request->requestvb,
                         (table_entry ? RS_ACTIVE : RS_NONEXISTENT ));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error( reqinfo, request,
                                           SNMP_ERR_NOTWRITABLE );
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451TimTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_NEWROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                case RS_CREATEANDWAIT:
                    table_row = ieeeP1451TimTable_createEntry(
                        *table_info->indexes->val.integer
                        );
                    if (table_row) {
                        netsnmp_insert_iterator_context( request, table_row );
                    } else {
                        netsnmp_set_request_error( reqinfo, request,
                                                   SNMP_ERR_RESOURCEUNAVAILABLE );
                        return SNMP_ERR_NOERROR;
                    }
                }
            }
        }
        break;

    case MODE_SET_FREE:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451TimTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_NEWROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                case RS_CREATEANDWAIT:
                    if (table_entry && !table_entry->valid) {
                        ieeeP1451TimTable_removeEntry(table_entry);
                    }
                }
            }
        }
        break;

    case MODE_SET_ACTION:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451TimTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            }
        }
        /* Check the internal consistency of an active row */
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451TimTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_NEWROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_ACTIVE:
                case RS_CREATEANDGO:
                    if (0/* XXX */) {
                        netsnmp_set_request_error( reqinfo, request,
                                                   SNMP_ERR_INCONSISTENTVALUE );
                        return SNMP_ERR_NOERROR;
                    }
                }
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451TimTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_NEWROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                case RS_CREATEANDWAIT:
                    if (table_entry && !table_entry->valid) {
                        ieeeP1451TimTable_removeEntry(table_entry);
                    }
                }
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451TimTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_NEWROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                    table_entry->valid = 1;
                    /* Fall-through */
                case RS_ACTIVE:
                    table_entry->newRowStatus = RS_ACTIVE;
                    break;

                case RS_CREATEANDWAIT:
                    table_entry->valid = 1;
                    /* Fall-through */
                case RS_NOTINSERVICE:
                    table_entry->newRowStatus = RS_NOTINSERVICE;
                    break;

                case RS_DESTROY:
                    ieeeP1451TimTable_removeEntry(table_entry);
                }
            }
        }
        break;
    }
    return SNMP_ERR_NOERROR;
}
//   # Determine the first/last column names

/** Initialize the ieeeP1451ChannelTable table by defining its contents and how it's structured */
void
initialize_table_ieeeP1451ChannelTable(void)
{
    const oid ieeeP1451ChannelTable_oid[] = {1,3,6,1,4,1,7934,1451,2};
    const size_t ieeeP1451ChannelTable_oid_len   = OID_LENGTH(ieeeP1451ChannelTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("ieeeP1451Project3:init", "initializing table ieeeP1451ChannelTable\n"));

    reg = netsnmp_create_handler_registration(
              "ieeeP1451ChannelTable",     ieeeP1451ChannelTable_handler,
              ieeeP1451ChannelTable_oid, ieeeP1451ChannelTable_oid_len,
              HANDLER_CAN_RWRITE
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: timID */
                           ASN_INTEGER,  /* index: channelID */
                           0);
    table_info->min_column = COLUMN_TIMID;
    table_info->max_column = COLUMN_P1451ROWSTATUS;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = ieeeP1451ChannelTable_get_first_data_point;
    iinfo->get_next_data_point  = ieeeP1451ChannelTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );
    netsnmp_inject_handler_before( reg, 
        netsnmp_get_cache_handler(IEEEP1451CHANNELTABLE_TIMEOUT,
                                  ieeeP1451ChannelTable_load, ieeeP1451ChannelTable_free,
                                  ieeeP1451ChannelTable_oid, ieeeP1451ChannelTable_oid_len),
            TABLE_ITERATOR_NAME);

    /* Initialise the contents of the table here */
}


/* create a new row in the (unsorted) table */
struct ieeeP1451ChannelTable_entry *
ieeeP1451ChannelTable_createEntry(
                 long  timID,
                 long  channelID
                ) {
    struct ieeeP1451ChannelTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct ieeeP1451ChannelTable_entry);
    if (!entry)
        return NULL;

    entry->timID = timID;
    entry->channelID = channelID;
    entry->next = ieeeP1451ChannelTable_head;
    ieeeP1451ChannelTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
ieeeP1451ChannelTable_removeEntry( struct ieeeP1451ChannelTable_entry *entry ) {
    struct ieeeP1451ChannelTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = ieeeP1451ChannelTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        ieeeP1451ChannelTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}


/* Example cache handling - set up linked list from a suitable file */
int
ieeeP1451ChannelTable_load( netsnmp_cache *cache, void *vmagic ) {
    FILE *fp;
    struct ieeeP1451ChannelTable_entry *this;
    char buf[STRMAX];

    /* The basic load routine template assumes that the data to
       be reported is held in a file - with one row of the file
       for each row of the table.
          If your data is available via a different API, you
       should amend this initial block (and the control of the
       'while' loop) accordingly.
          'XXX' marks where the template is incomplete and
       code will definitely need to be added. */

    fp = fopen( "/data/for/ieeeP1451ChannelTable", "r" );
    if ( !fp ) {
        return -1;
    }
    while ( fgets( buf, STRMAX, fp )) {
        this = SNMP_MALLOC_TYPEDEF( struct ieeeP1451ChannelTable_entry );
        /* XXX - Unpick 'buf' to extract the individual field values
                 and then populate the 'this' data structure with them */

        this->next = ieeeP1451ChannelTable_head;
        ieeeP1451ChannelTable_head = this;    /* Iterate helper is fine with unordered lists! */
    }
    fclose(fp);
    return 0;  /* OK */
}

void
ieeeP1451ChannelTable_free( netsnmp_cache *cache, void *vmagic ) {
    struct ieeeP1451ChannelTable_entry *this, *that;

    for ( this = ieeeP1451ChannelTable_head; this; this=that ) {
        that = this->next;
        SNMP_FREE( this );   /* XXX - release any other internal resources */
    }
    ieeeP1451ChannelTable_head = NULL;
}

/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
ieeeP1451ChannelTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = ieeeP1451ChannelTable_head;
    return ieeeP1451ChannelTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
ieeeP1451ChannelTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct ieeeP1451ChannelTable_entry *entry = (struct ieeeP1451ChannelTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->timID );
        idx = idx->next_variable;
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->channelID );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the ieeeP1451ChannelTable table */
int
ieeeP1451ChannelTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct ieeeP1451ChannelTable_entry          *table_entry;
    struct userTable_entry *table_row;
    int ret;

    DEBUGMSGTL(("ieeeP1451Project3:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451ChannelTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_TIMID:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->timID);
                break;
            case COLUMN_CHANNELID:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->channelID);
                break;
            case COLUMN_COMMUTYPE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->commuType,
                                          table_entry->commuType_len);
                break;
            case COLUMN_COMMUADDRESS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->commuAddress,
                                          table_entry->commuAddress_len);
                break;
            case COLUMN_TESTVALUE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->testValue,
                                          table_entry->testValue_len);
                break;
            case COLUMN_P1451ROWSTATUS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->p1451RowStatus);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451ChannelTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_COMMUTYPE:
          /* or possibly 'netsnmp_check_vb_type_and_size' */
                ret = netsnmp_check_vb_type_and_max_size(
                          request->requestvb, ASN_OCTET_STR, sizeof(table_entry->commuType));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_COMMUADDRESS:
          /* or possibly 'netsnmp_check_vb_type_and_size' */
                ret = netsnmp_check_vb_type_and_max_size(
                          request->requestvb, ASN_OCTET_STR, sizeof(table_entry->commuAddress));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_P1451ROWSTATUS:
                ret = netsnmp_check_vb_rowstatus(request->requestvb,
                         (table_entry ? RS_ACTIVE : RS_NONEXISTENT ));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error( reqinfo, request,
                                           SNMP_ERR_NOTWRITABLE );
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451ChannelTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_P1451ROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                case RS_CREATEANDWAIT:
                    table_row = ieeeP1451ChannelTable_createEntry(
                        *table_info->indexes->val.integer
                        ,  *table_info->indexes->next_variable->val.integer
                        );
                    if (table_row) {
                        netsnmp_insert_iterator_context( request, table_row );
                    } else {
                        netsnmp_set_request_error( reqinfo, request,
                                                   SNMP_ERR_RESOURCEUNAVAILABLE );
                        return SNMP_ERR_NOERROR;
                    }
                }
            }
        }
        break;

    case MODE_SET_FREE:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451ChannelTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_P1451ROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                case RS_CREATEANDWAIT:
                    if (table_entry && !table_entry->valid) {
                        ieeeP1451ChannelTable_removeEntry(table_entry);
                    }
                }
            }
        }
        break;

    case MODE_SET_ACTION:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451ChannelTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_COMMUTYPE:
                memcpy( table_entry->old_commuType,
                        table_entry->commuType,
                        sizeof(table_entry->commuType));
                table_entry->old_commuType_len =
                        table_entry->commuType_len;
                memset( table_entry->commuType, 0,
                        sizeof(table_entry->commuType));
                memcpy( table_entry->commuType,
                        request->requestvb->val.string,
                        request->requestvb->val_len);
                table_entry->commuType_len =
                        request->requestvb->val_len;
                break;
            case COLUMN_COMMUADDRESS:
                memcpy( table_entry->old_commuAddress,
                        table_entry->commuAddress,
                        sizeof(table_entry->commuAddress));
                table_entry->old_commuAddress_len =
                        table_entry->commuAddress_len;
                memset( table_entry->commuAddress, 0,
                        sizeof(table_entry->commuAddress));
                memcpy( table_entry->commuAddress,
                        request->requestvb->val.string,
                        request->requestvb->val_len);
                table_entry->commuAddress_len =
                        request->requestvb->val_len;
                break;
            }
        }
        /* Check the internal consistency of an active row */
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451ChannelTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_P1451ROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_ACTIVE:
                case RS_CREATEANDGO:
                    if (0/* XXX */) {
                        netsnmp_set_request_error( reqinfo, request,
                                                   SNMP_ERR_INCONSISTENTVALUE );
                        return SNMP_ERR_NOERROR;
                    }
                }
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451ChannelTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_COMMUTYPE:
                memcpy( table_entry->commuType,
                        table_entry->old_commuType,
                        sizeof(table_entry->commuType));
                memset( table_entry->old_commuType, 0,
                        sizeof(table_entry->commuType));
                table_entry->commuType_len =
                        table_entry->old_commuType_len;
                break;
            case COLUMN_COMMUADDRESS:
                memcpy( table_entry->commuAddress,
                        table_entry->old_commuAddress,
                        sizeof(table_entry->commuAddress));
                memset( table_entry->old_commuAddress, 0,
                        sizeof(table_entry->commuAddress));
                table_entry->commuAddress_len =
                        table_entry->old_commuAddress_len;
                break;
            case COLUMN_P1451ROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                case RS_CREATEANDWAIT:
                    if (table_entry && !table_entry->valid) {
                        ieeeP1451ChannelTable_removeEntry(table_entry);
                    }
                }
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451ChannelTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_P1451ROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                    table_entry->valid = 1;
                    /* Fall-through */
                case RS_ACTIVE:
                    table_entry->p1451RowStatus = RS_ACTIVE;
                    break;

                case RS_CREATEANDWAIT:
                    table_entry->valid = 1;
                    /* Fall-through */
                case RS_NOTINSERVICE:
                    table_entry->p1451RowStatus = RS_NOTINSERVICE;
                    break;

                case RS_DESTROY:
                    ieeeP1451ChannelTable_removeEntry(table_entry);
                }
            }
        }
        break;
    }
    return SNMP_ERR_NOERROR;
}
