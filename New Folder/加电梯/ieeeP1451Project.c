/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "ieeeP1451Project.h"


#include <Python.h>
#include <stdarg.h>

unsigned char buf[1024];

/* for acceptable `arg_format' `ret_val_format', see https://docs.python.org/2.7/c-api/arg.html */
int int_py_caller(char *python_module_name, char *python_func_name, char *arg_format, char *ret_val_format, ...)
{
  PyObject *python_module_object    = NULL;
  PyObject *python_arg_object   = NULL;
  PyObject *python_func_object    = NULL;
  PyObject *python_return_val_object  = NULL;

  va_list vl; /* this is used to parse the arguments in the `...' part. see stdarg(3) */

  Py_Initialize();

  /* these two lines are required, if any custom module under the current working dirctory is to be loaded */
  PyRun_SimpleString("import sys");
  PyRun_SimpleString("sys.path.append('.')");

  python_module_object = PyImport_ImportModule(python_module_name); 
  if (!python_module_object) {
    printf("Error: cannot import module.\n");
    // return 0; // TODO:
  }

  python_func_object = PyObject_GetAttrString(python_module_object, python_func_name);
  if (!python_func_object) {
    printf("Error: cannot import function.\n");
    // return 0; // TODO:
  }

  /* start parsing arguments */
  va_start(vl, ret_val_format);
  /* construct arguments for the python function using the arguments passed to this C function */
  python_arg_object = Py_VaBuildValue(arg_format, vl);
  if (!python_arg_object) {
    printf("Error: cannot construct arguments.\n");
    // return 0; // TODO:
  }
  /* finish parsing arguments */
  va_end(vl);

  // PyObject_Print(python_arg_object, stdout, 0/*Py_PRINT_RAW*/); /* the 3rd arg controls either using `str()' or `repr()' */
  // printf("\n");


  /* `python_arg_object' should be a tuple */
  python_return_val_object = PyEval_CallObject(python_func_object, python_arg_object);
  if (!python_return_val_object) {
    printf("Error: function not called successfully.\n");
    // return 0; // TODO:
  }

  // TODO: another function? use tuple or not? what if multiple return value?
  // after experiemnt, PyArg_Parse can't use tuple
  if (!PyArg_Parse(python_return_val_object, ret_val_format, buf)) {
    printf("Error: cannot parse return value.\n");
    // return 0; // TODO:
  }

  // TODO: unified way of handling types
  printf("%d\n", *((int *) buf));

  Py_DECREF(python_module_object);
  Py_DECREF(python_func_object);
  Py_DECREF(python_arg_object);
  Py_DECREF(python_return_val_object);

  return *((int *) buf);
}

/* STARTS */

#include  <stdlib.h>
#include  <time.h>

#define   TEMPERATURE_FLUCTUATION   2
#define   LIGHT_FLUCTUATION   4
#define   LCD_STRING_MAX_LEN    10240
#define   Getfree1_STRING_MAX_LEN    10240
#define   Getfree2_STRING_MAX_LEN    10240
#define   Getfree3_STRING_MAX_LEN    10240

long  value_of_temperature;
long  value_of_light;
long  base_value_of_temperature   = 140;
long  base_value_of_light     = 120;
long  gain_value_of_light_when_lamp_on  = 60;
long  status_of_lamp        = 0;
long  status_of_humdifier     = 0;
char  lcd_display_string[LCD_STRING_MAX_LEN]  = "Good morning!";
int lcd_display_string_len      = 13;

long  value_of_Temperature;
long  value_of_Light;
long  value_of_Humidity;
long  value_of_Distence;
long  value_of_Accelerationx;
long  value_of_Accelerationy;
long  value_of_Accelerationz;
long  value_of_HS;
long  value_of_LoadVoltage;
long  value_of_LoadCurrent;
long  value_of_LoadPower;
long  value_of_Pressure;
long  value_of_SeFree1;
long  value_of_SeFree2;
long  value_of_Lamp;
long  value_of_Hunidifier;
long  value_of_buzzer;
long  value_of_LEDScreen;
long  value_of_AcFree1;
long  value_of_AcFree2;
long  value_of_Getfloors;
long  value_of_GetStatusofDoor;
long  value_of_GetStatusofLamp;
long  value_of_Getfree1;
long  value_of_Getfree2;
long  value_of_Getfree3;
int   value_of_Getfree1_len      = 23;
int   value_of_Getfree2_len      = 23;
int   value_of_Getfree3_len      = 23;
long  value_of_Getfree4;
long  value_of_Getfree5;
long  value_of_Getfree6;
long  value_of_Getfree7;
long  value_of_Setfloors;
long  value_of_SetStateofDoor;
long  value_of_Setfree1;
long  value_of_Setfree2;
long  value_of_Setfree3;
long  value_of_Setfree4;
long  value_of_Setfree5;
long  value_of_Setfree6;
long  value_of_Setfree7;


long
randl(long max)
{
  return ((long) rand()) % max;
}

/* ENDS*/






/** Initializes the ieeeP1451Project module */
void
init_ieeeP1451Project(void)
{
    const oid SeTemperature_oid[] = { 1,3,6,1,4,1,7934,1451,1,1 };
    const oid SeLight_oid[] = { 1,3,6,1,4,1,7934,1451,1,2 };
    const oid SeHumidity_oid[] = { 1,3,6,1,4,1,7934,1451,1,3 };
    const oid SeDistence_oid[] = { 1,3,6,1,4,1,7934,1451,1,4 };
    const oid SeAccelerationx_oid[] = { 1,3,6,1,4,1,7934,1451,1,5 };
    const oid SeAccelerationy_oid[] = { 1,3,6,1,4,1,7934,1451,1,6 };
    const oid SeAccelerationz_oid[] = { 1,3,6,1,4,1,7934,1451,1,7 };
    const oid SeHS_oid[] = { 1,3,6,1,4,1,7934,1451,1,8 };
    const oid SeLoadVoltage_oid[] = { 1,3,6,1,4,1,7934,1451,1,9 };
    const oid SeLoadCurrent_oid[] = { 1,3,6,1,4,1,7934,1451,1,10 };
    const oid SeLoadPower_oid[] = { 1,3,6,1,4,1,7934,1451,1,11 };
    const oid SePressure_oid[] = { 1,3,6,1,4,1,7934,1451,1,12 };
    const oid SeFree1_oid[] = { 1,3,6,1,4,1,7934,1451,1,13 };
    const oid SeFree2_oid[] = { 1,3,6,1,4,1,7934,1451,1,14 };
    const oid AcLamp_oid[] = { 1,3,6,1,4,1,7934,1451,2,1 };
    const oid AcHunidifier_oid[] = { 1,3,6,1,4,1,7934,1451,2,2 };
    const oid Acbuzzer_oid[] = { 1,3,6,1,4,1,7934,1451,2,3 };
    const oid AcLEDScreen_oid[] = { 1,3,6,1,4,1,7934,1451,2,4 };
    const oid AcFree1_oid[] = { 1,3,6,1,4,1,7934,1451,2,5 };
    const oid AcFree2_oid[] = { 1,3,6,1,4,1,7934,1451,2,6 };
    const oid Getfloors_oid[] = { 1,3,6,1,4,1,7934,1451,6,1 };
    const oid GetStatusofDoor_oid[] = { 1,3,6,1,4,1,7934,1451,6,2 };
    const oid GetStatusofLamp_oid[] = { 1,3,6,1,4,1,7934,1451,6,3 };
    const oid Getfree1_oid[] = { 1,3,6,1,4,1,7934,1451,6,4 };
    const oid Getfree2_oid[] = { 1,3,6,1,4,1,7934,1451,6,5 };
    const oid Getfree3_oid[] = { 1,3,6,1,4,1,7934,1451,6,6 };
    const oid Getfree4_oid[] = { 1,3,6,1,4,1,7934,1451,6,7 };
    const oid Getfree5_oid[] = { 1,3,6,1,4,1,7934,1451,6,8 };
    const oid Getfree6_oid[] = { 1,3,6,1,4,1,7934,1451,6,9 };
    const oid Getfree7_oid[] = { 1,3,6,1,4,1,7934,1451,6,10 };
    const oid Setfloors_oid[] = { 1,3,6,1,4,1,7934,1451,7,1 };
    const oid SetStateofDoor_oid[] = { 1,3,6,1,4,1,7934,1451,7,2 };
    const oid Setfree1_oid[] = { 1,3,6,1,4,1,7934,1451,7,3 };
    const oid Setfree2_oid[] = { 1,3,6,1,4,1,7934,1451,7,4 };
    const oid Setfree3_oid[] = { 1,3,6,1,4,1,7934,1451,7,5 };
    const oid Setfree4_oid[] = { 1,3,6,1,4,1,7934,1451,7,6 };
    const oid Setfree5_oid[] = { 1,3,6,1,4,1,7934,1451,7,7 };
    const oid Setfree6_oid[] = { 1,3,6,1,4,1,7934,1451,7,8 };
    const oid Setfree7_oid[] = { 1,3,6,1,4,1,7934,1451,7,9 };
    const oid Setfree7_oid[] = { 1,3,6,1,4,1,7934,1451,8,1 };

  DEBUGMSGTL(("ieeeP1451Project", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeTemperature", handle_SeTemperature,
                               SeTemperature_oid, OID_LENGTH(SeTemperature_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeLight", handle_SeLight,
                               SeLight_oid, OID_LENGTH(SeLight_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeHumidity", handle_SeHumidity,
                               SeHumidity_oid, OID_LENGTH(SeHumidity_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeDistence", handle_SeDistence,
                               SeDistence_oid, OID_LENGTH(SeDistence_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeAccelerationx", handle_SeAccelerationx,
                               SeAccelerationx_oid, OID_LENGTH(SeAccelerationx_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeAccelerationy", handle_SeAccelerationy,
                               SeAccelerationy_oid, OID_LENGTH(SeAccelerationy_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeAccelerationz", handle_SeAccelerationz,
                               SeAccelerationz_oid, OID_LENGTH(SeAccelerationz_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeHS", handle_SeHS,
                               SeHS_oid, OID_LENGTH(SeHS_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeLoadVoltage", handle_SeLoadVoltage,
                               SeLoadVoltage_oid, OID_LENGTH(SeLoadVoltage_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeLoadCurrent", handle_SeLoadCurrent,
                               SeLoadCurrent_oid, OID_LENGTH(SeLoadCurrent_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeLoadPower", handle_SeLoadPower,
                               SeLoadPower_oid, OID_LENGTH(SeLoadPower_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SePressure", handle_SePressure,
                               SePressure_oid, OID_LENGTH(SePressure_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeFree1", handle_SeFree1,
                               SeFree1_oid, OID_LENGTH(SeFree1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeFree2", handle_SeFree2,
                               SeFree2_oid, OID_LENGTH(SeFree2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("AcLamp", handle_AcLamp,
                               AcLamp_oid, OID_LENGTH(AcLamp_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("AcHunidifier", handle_AcHunidifier,
                               AcHunidifier_oid, OID_LENGTH(AcHunidifier_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("Acbuzzer", handle_Acbuzzer,
                               Acbuzzer_oid, OID_LENGTH(Acbuzzer_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("AcLEDScreen", handle_AcLEDScreen,
                               AcLEDScreen_oid, OID_LENGTH(AcLEDScreen_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("AcFree1", handle_AcFree1,
                               AcFree1_oid, OID_LENGTH(AcFree1_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("AcFree2", handle_AcFree2,
                               AcFree2_oid, OID_LENGTH(AcFree2_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("Getfloors", handle_Getfloors,
                               Getfloors_oid, OID_LENGTH(Getfloors_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("GetStatusofDoor", handle_GetStatusofDoor,
                               GetStatusofDoor_oid, OID_LENGTH(GetStatusofDoor_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("GetStatusofLamp", handle_GetStatusofLamp,
                               GetStatusofLamp_oid, OID_LENGTH(GetStatusofLamp_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("Getfree1", handle_Getfree1,
                               Getfree1_oid, OID_LENGTH(Getfree1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("Getfree2", handle_Getfree2,
                               Getfree2_oid, OID_LENGTH(Getfree2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("Getfree3", handle_Getfree3,
                               Getfree3_oid, OID_LENGTH(Getfree3_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("Getfree4", handle_Getfree4,
                               Getfree4_oid, OID_LENGTH(Getfree4_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("Getfree5", handle_Getfree5,
                               Getfree5_oid, OID_LENGTH(Getfree5_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("Getfree6", handle_Getfree6,
                               Getfree6_oid, OID_LENGTH(Getfree6_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("Getfree7", handle_Getfree7,
                               Getfree7_oid, OID_LENGTH(Getfree7_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("Setfloors", handle_Setfloors,
                               Setfloors_oid, OID_LENGTH(Setfloors_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SetStateofDoor", handle_SetStateofDoor,
                               SetStateofDoor_oid, OID_LENGTH(SetStateofDoor_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("Setfree1", handle_Setfree1,
                               Setfree1_oid, OID_LENGTH(Setfree1_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("Setfree2", handle_Setfree2,
                               Setfree2_oid, OID_LENGTH(Setfree2_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("Setfree3", handle_Setfree3,
                               Setfree3_oid, OID_LENGTH(Setfree3_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("Setfree4", handle_Setfree4,
                               Setfree4_oid, OID_LENGTH(Setfree4_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("Setfree5", handle_Setfree5,
                               Setfree5_oid, OID_LENGTH(Setfree5_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("Setfree6", handle_Setfree6,
                               Setfree6_oid, OID_LENGTH(Setfree6_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("Setfree7", handle_Setfree7,
                               Setfree7_oid, OID_LENGTH(Setfree7_oid),
                               HANDLER_CAN_RWRITE
        ));
}

int
handle_SeTemperature(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          value_of_Temperature = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 10);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Temperature,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeTemperature\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeLight(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          value_of_Light = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 11);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Light,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeLight\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeHumidity(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          value_of_Humidity = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 12);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Humidity,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeHumidity\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeDistence(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          value_of_Distence = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 13);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Distence,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeDistence\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeAccelerationx(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          value_of_Accelerationx = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 14);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Accelerationx,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeAccelerationx\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeAccelerationy(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          value_of_Accelerationy = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 15);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Accelerationy,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeAccelerationy\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeAccelerationz(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          value_of_Accelerationz = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 16);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Accelerationz,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeAccelerationz\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeHS(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          value_of_HS = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 17);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_HS,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeHS\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeLoadVoltage(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          value_of_LoadVoltage = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 18);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_LoadVoltage,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeLoadVoltage\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeLoadCurrent(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          value_of_LoadCurrent = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 19);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_LoadCurrent,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeLoadCurrent\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeLoadPower(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          value_of_LoadPower = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 110);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_LoadPower,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeLoadPower\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SePressure(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          value_of_Pressure = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 111);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Pressure,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SePressure\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeFree1(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          value_of_SeFree1 = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 112);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_SeFree1,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeFree1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeFree2(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          value_of_SeFree2 = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 113);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_SeFree2,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeFree2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_AcLamp(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          value_of_Lamp = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 20);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Lamp,
                                           (size_t) 8);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //      XXX malloc "undo" storage buffer 
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
              /* STARTS */
              value_of_Lamp = *(requests->requestvb->val.integer);
              if (value_of_Lamp)
                value_of_Lamp = 1;
              int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 20, value_of_Lamp);
              /* ENDS */
            break;

        // case MODE_SET_COMMIT:

        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_AcLamp\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_AcHunidifier(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          value_of_Hunidifier = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 21);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Hunidifier,
                                           (size_t) 8);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //     /* XXX malloc "undo" storage buffer */
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
              /* STARTS */
              value_of_Hunidifier = *(requests->requestvb->val.integer);
              // if (value_of_Hunidifier)
              //   value_of_Hunidifier = 1;
              int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 21, value_of_Hunidifier);
              /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_AcHunidifier\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_Acbuzzer(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_buzzer = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 22);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_buzzer,
                                           (size_t) 8);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //      XXX malloc "undo" storage buffer 
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
              /* STARTS */
              value_of_buzzer = *(requests->requestvb->val.integer);
              // if (value_of_buzzer)
              //   value_of_buzzer = 1;
              int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 22, value_of_buzzer);
              /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_Acbuzzer\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_AcLEDScreen(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_LEDScreen = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 23);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_LEDScreen,
                                           (size_t) 8);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //      XXX malloc "undo" storage buffer 
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
              /* STARTS */
              value_of_LEDScreen = *(requests->requestvb->val.integer);
              // if (value_of_LEDScreen)
              //   value_of_LEDScreen = 1;
              int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 23, value_of_LEDScreen);
              /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_AcLEDScreen\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_AcFree1(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_AcFree1 = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 24);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_AcFree1,
                                           (size_t) 8);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //      XXX malloc "undo" storage buffer 
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
              /* STARTS */
              value_of_AcFree1 = *(requests->requestvb->val.integer);
              // if (value_of_AcFree1)
              //   value_of_AcFree1 = 1;
              int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 24, value_of_AcFree1);
              /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_AcFree1\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_AcFree2(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_AcFree2 = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 25);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_AcFree2,
                                           (size_t) 8);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //      XXX malloc "undo" storage buffer 
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
              /* STARTS */
              value_of_AcFree2 = *(requests->requestvb->val.integer);
              // if (value_of_AcFree2)
              //   value_of_AcFree2 = 1;
              int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 25, value_of_AcFree2);
              /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_AcFree2\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_Getfloors(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_Getfloors = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 30);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Getfloors,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_Getfloors\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_GetStatusofDoor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_GetStatusofDoor = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 31);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_GetStatusofDoor,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_GetStatusofDoor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_GetStatusofLamp(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_GetStatusofLamp = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 32);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_GetStatusofLamp,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_GetStatusofLamp\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_Getfree1(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_Getfree1 = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 33);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Getfree1,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_Getfree1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_Getfree2(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_Getfree2 = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 34);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Getfree2,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_Getfree2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_Getfree3(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_Getfree3 = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 35);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Getfree3,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_Getfree3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_Getfree4(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_Getfree4 = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 36);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Getfree4,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_Getfree4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_Getfree5(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_Getfree5 = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 37);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Getfree5,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_Getfree5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_Getfree6(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_Getfree6 = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 38);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Getfree6,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_Getfree6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_Getfree7(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_Getfree7 = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 39);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Getfree7,
                                           (size_t) 8);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_Getfree7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_Setfloors(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_Setfloors = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 40);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Setfloors,
                                           (size_t) 8);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //     /* XXX malloc "undo" storage buffer */
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
              /* STARTS */
              value_of_Setfloors = *(requests->requestvb->val.integer);
              // if (value_of_Setfloors)
              //   value_of_Setfloors = 1;
              int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 40, value_of_Setfloors);
              /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_Setfloors\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SetStateofDoor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_SetStateofDoor = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 41);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_SetStateofDoor,
                                           (size_t) 8);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //      XXX malloc "undo" storage buffer 
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
              /* STARTS */
              value_of_SetStateofDoor = *(requests->requestvb->val.integer);
              // if (value_of_SetStateofDoor)
              //   value_of_SetStateofDoor = 1;
              int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 41, value_of_SetStateofDoor);
              /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_SetStateofDoor\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_Setfree1(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_Setfree1 = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 42);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Setfree1,
                                           (size_t) 8);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //      XXX malloc "undo" storage buffer 
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
              /* STARTS */
              value_of_Setfree1 = *(requests->requestvb->val.integer);
              // if (value_of_Setfree1)
              //   value_of_Setfree1 = 1;
              int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 42, value_of_Setfree1);
              /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_Setfree1\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_Setfree2(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_Setfree2 = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 43);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Setfree2,
                                           (size_t) 8);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //     /* XXX malloc "undo" storage buffer */
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
              /* STARTS */
              value_of_Setfree2 = *(requests->requestvb->val.integer);
              // if (value_of_Setfree2)
              //   value_of_Setfree2 = 1;
              int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 43, value_of_Setfree2);
              /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_Setfree2\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_Setfree3(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_Setfree3 = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 44);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Setfree3,
                                           (size_t) 8);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //     /* XXX malloc "undo" storage buffer */
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
              /* STARTS */
              value_of_Setfree3 = *(requests->requestvb->val.integer);
              // if (value_of_Setfree3)
              //   value_of_Setfree3 = 1;
              int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 44, value_of_Setfree3);
              /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_Setfree3\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_Setfree4(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_Setfree4 = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 45);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Setfree4,
                                           (size_t) 8);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //     /* XXX malloc "undo" storage buffer */
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
              /* STARTS */
              value_of_Setfree4 = *(requests->requestvb->val.integer);
              // if (value_of_Setfree4)
              //   value_of_Setfree4 = 1;
              int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 45, value_of_Setfree4);
              /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_Setfree4\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_Setfree5(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_Setfree5 = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 46);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Setfree5,
                                           (size_t) 8);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //      XXX malloc "undo" storage buffer 
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
              /* STARTS */
              value_of_Setfree5 = *(requests->requestvb->val.integer);
              // if (value_of_Setfree5)
              //   value_of_Setfree5 = 1;
              int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 46, value_of_Setfree5);
              /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_Setfree5\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_Setfree6(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_Setfree6 = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 47);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Setfree6,
                                           (size_t) 8);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //      XXX malloc "undo" storage buffer 
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
              /* STARTS */
              value_of_Setfree6 = *(requests->requestvb->val.integer);
              // if (value_of_Setfree6)
              //   value_of_Setfree6 = 1;
              int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 47, value_of_Setfree6);
              /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_Setfree6\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_Setfree7(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
           value_of_Setfree7 = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 48);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Setfree7,
                                           (size_t) 8);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //      XXX malloc "undo" storage buffer 
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
              /* STARTS */
              value_of_Setfree7 = *(requests->requestvb->val.integer);
              // if (value_of_Setfree7)
              //   value_of_Setfree7 = 1;
              int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 48, value_of_Setfree7);
              /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_Setfree7\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
