/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "ieeeP1451Project.h"

#include <Python.h>
#include <stdarg.h>

unsigned char buf[1024];

/* for acceptable `arg_format' `ret_val_format', see https://docs.python.org/2.7/c-api/arg.html */
int int_py_caller(char *python_module_name, char *python_func_name, char *arg_format, char *ret_val_format, ...)
{
	PyObject *python_module_object		= NULL;
	PyObject *python_arg_object		= NULL;
	PyObject *python_func_object		= NULL;
	PyObject *python_return_val_object	= NULL;

	va_list vl; /* this is used to parse the arguments in the `...' part. see stdarg(3) */

	Py_Initialize();

	/* these two lines are required, if any custom module under the current working dirctory is to be loaded */
	PyRun_SimpleString("import sys");
	PyRun_SimpleString("sys.path.append('.')");

	python_module_object = PyImport_ImportModule(python_module_name); 
	if (!python_module_object) {
		printf("Error: cannot import module.\n");
		// return 0; // TODO:
	}

	python_func_object = PyObject_GetAttrString(python_module_object, python_func_name);
	if (!python_func_object) {
		printf("Error: cannot import function.\n");
		// return 0; // TODO:
	}

	/* start parsing arguments */
	va_start(vl, ret_val_format);
	/* construct arguments for the python function using the arguments passed to this C function */
	python_arg_object = Py_VaBuildValue(arg_format, vl);
	if (!python_arg_object) {
		printf("Error: cannot construct arguments.\n");
		// return 0; // TODO:
	}
	/* finish parsing arguments */
	va_end(vl);

	// PyObject_Print(python_arg_object, stdout, 0/*Py_PRINT_RAW*/); /* the 3rd arg controls either using `str()' or `repr()' */
	// printf("\n");


	/* `python_arg_object' should be a tuple */
	python_return_val_object = PyEval_CallObject(python_func_object, python_arg_object);
	if (!python_return_val_object) {
		printf("Error: function not called successfully.\n");
		// return 0; // TODO:
	}

	// TODO: another function? use tuple or not? what if multiple return value?
	// after experiemnt, PyArg_Parse can't use tuple
	if (!PyArg_Parse(python_return_val_object, ret_val_format, buf)) {
		printf("Error: cannot parse return value.\n");
		// return 0; // TODO:
	}

	// TODO: unified way of handling types
	printf("%d\n", *((int *) buf));

	Py_DECREF(python_module_object);
	Py_DECREF(python_func_object);
	Py_DECREF(python_arg_object);
	Py_DECREF(python_return_val_object);

	return *((int *) buf);
}

/* STARTS */

#include	<stdlib.h>
#include	<time.h>

#define		TEMPERATURE_FLUCTUATION		2
#define		LIGHT_FLUCTUATION		4
#define		LCD_STRING_MAX_LEN		10240

long	value_of_temperature;
long	value_of_light;
long	base_value_of_temperature		= 140;
long	base_value_of_light			= 120;
long	gain_value_of_light_when_lamp_on	= 60;
long	status_of_lamp				= 0;
long	status_of_humdifier			= 0;
char	lcd_display_string[LCD_STRING_MAX_LEN]	= "Good morning!";
int	lcd_display_string_len			= 13;

long
randl(long max)
{
	return ((long) rand()) % max;
}

/* ENDS*/

/** Initializes the ieeeP1451Project module */
void
init_ieeeP1451Project(void)
{
    const oid seTemperature_oid[] = { 1,3,6,1,4,1,7934,1451,1,1 };
    const oid seLight_oid[] = { 1,3,6,1,4,1,7934,1451,1,2 };
    const oid acLamp_oid[] = { 1,3,6,1,4,1,7934,1451,2,1 };
    const oid acHumidifier_oid[] = { 1,3,6,1,4,1,7934,1451,2,2 };
    const oid acLcd_oid[] = { 1,3,6,1,4,1,7934,1451,2,3 };

  DEBUGMSGTL(("ieeeP1451Project", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("seTemperature", handle_seTemperature,
                               seTemperature_oid, OID_LENGTH(seTemperature_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("seLight", handle_seLight,
                               seLight_oid, OID_LENGTH(seLight_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("acLamp", handle_acLamp,
                               acLamp_oid, OID_LENGTH(acLamp_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("acHumidifier", handle_acHumidifier,
                               acHumidifier_oid, OID_LENGTH(acHumidifier_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("acLcd", handle_acLcd,
                               acLcd_oid, OID_LENGTH(acLcd_oid),
                               HANDLER_CAN_RWRITE
        ));

	/* STARTS */
	/* random number seed init */
	srand(time(0));
	/* ENDS */
}

int
handle_seTemperature(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
		/* STARTS */
		value_of_temperature = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 0);
		// value_of_temperature = base_value_of_temperature 
		//                      + randl(TEMPERATURE_FLUCTUATION)
		//                      - TEMPERATURE_FLUCTUATION / 2;
            snmp_set_var_typed_value(requests->requestvb,
                                     ASN_INTEGER,
                                     &value_of_temperature,
                                     (size_t) 8);
		/* ENDS */
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_seTemperature\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_seLight(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
		/* STARTS */
		value_of_light = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 1);
		// value_of_light = base_value_of_light
		//                + ((long) status_of_lamp) * gain_value_of_light_when_lamp_on
		//                + randl(LIGHT_FLUCTUATION)
		//                - LIGHT_FLUCTUATION / 2;
            snmp_set_var_typed_value(requests->requestvb,
                                     ASN_INTEGER,
                                     &value_of_light,
                                     (size_t) 8);
		/* ENDS */
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_seLight\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_acLamp(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
		/* STARTS */
		status_of_lamp = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 2);
            snmp_set_var_typed_value(requests->requestvb,
                                     ASN_INTEGER,
                                     &status_of_lamp,
                                     (size_t) 8);
		/* ENDS */
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //     /* XXX malloc "undo" storage buffer */
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
		/* STARTS */
		status_of_lamp = *(requests->requestvb->val.integer);
		if (status_of_lamp)
			status_of_lamp = 1;
		int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 4, status_of_lamp);
		/* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_acLamp\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_acHumidifier(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
		/* STARTS */
		status_of_humdifier = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 3);
            snmp_set_var_typed_value(requests->requestvb,
                                     ASN_INTEGER,
                                     &status_of_humdifier,
                                     (size_t) 8);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //     /* XXX malloc "undo" storage buffer */
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
		/* STARTS */
		status_of_humdifier = *(requests->requestvb->val.integer);
		if (status_of_humdifier)
			status_of_humdifier = 1;
		int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 5, status_of_humdifier);
		/* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_acHumidifier\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_acLcd(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;

    /* STARTS */
    int i;
    /* ENDS */

    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
		/* STARTS */
            snmp_set_var_typed_value(requests->requestvb,
                                     ASN_OCTET_STR,
                                     lcd_display_string,
                                     (size_t) lcd_display_string_len);
		/* ENDS */
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //     /* XXX malloc "undo" storage buffer */
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
		/* STARTS */
		if (requests->requestvb->val_len > LCD_STRING_MAX_LEN)
			break;
		lcd_display_string_len = (int) (requests->requestvb->val_len);
		for (i = 0; i < lcd_display_string_len; i++)
			lcd_display_string[i] = requests->requestvb->val.string[i];
		/* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_acLcd\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}