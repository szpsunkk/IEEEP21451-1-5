/*
 * Note: this file originally auto-generated by mib2c using
 *  $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "ieeeP1451Project2.h"
#include <stdio.h>

/** Initializes the ieeeP1451Project2 module */
void
init_ieeeP1451Project2(void)
{
  /* here we initialize all the tables we're planning on supporting */
    initialize_table_ieeeP1451Table();
}

//  # Determine the first/last column names

/** Initialize the ieeeP1451Table table by defining its contents and how it's structured */
void
initialize_table_ieeeP1451Table(void)
{
    const oid ieeeP1451Table_oid[] = {1,3,6,1,4,1,7934,1451,1};
    const size_t ieeeP1451Table_oid_len   = OID_LENGTH(ieeeP1451Table_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("ieeeP1451Project2:init", "initializing table ieeeP1451Table\n"));

    reg = netsnmp_create_handler_registration(
              "ieeeP1451Table",     ieeeP1451Table_handler,
              ieeeP1451Table_oid, ieeeP1451Table_oid_len,
              HANDLER_CAN_RWRITE
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: timID */
                           ASN_INTEGER,  /* index: channelID */
                           0);
    table_info->min_column = COLUMN_TIMID;
    table_info->max_column = COLUMN_P1451ROWSTATUS;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = ieeeP1451Table_get_first_data_point;
    iinfo->get_next_data_point  = ieeeP1451Table_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );
    netsnmp_inject_handler_before( reg, 
        netsnmp_get_cache_handler(IEEEP1451TABLE_TIMEOUT,
                                  ieeeP1451Table_load, ieeeP1451Table_free,
                                   , ieeeP1451Table_oid_len),
            TABLE_ITERATOR_NAME);

    /* Initialise the contents of the table here */
}

#define NNN 256

    /* Typical data structure for a row entry */
struct ieeeP1451Table_entry {
    /* Index values */
    long timID;
    long channelID;

    /* Column values */
    // long timID;
    // long channelID;
    char commuType[NNN];
    size_t commuType_len;
    char old_commuType[NNN];
    size_t old_commuType_len;
    char commuAddress[NNN];
    size_t commuAddress_len;
    char old_commuAddress[NNN];
    size_t old_commuAddress_len;
    char testValue[NNN];
    size_t testValue_len;
    long p1451RowStatus;

    /* Illustrate using a simple linked list */
    int   valid;
    struct ieeeP1451Table_entry *next;
};

struct ieeeP1451Table_entry  *ieeeP1451Table_head;

/* create a new row in the (unsorted) table */
struct ieeeP1451Table_entry *
ieeeP1451Table_createEntry(
                 long  timID,
                 long  channelID
                ) {
    struct ieeeP1451Table_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct ieeeP1451Table_entry);
    if (!entry)
        return NULL;

    entry->timID = timID;
    entry->channelID = channelID;

    // snprintf(entry->commuType, sizeof(entry->commuType), "%s", commuType);
    // entry->commuType_len = commuType_len;

    // snprintf(entry->commuAddress, sizeof(entry->commuAddress), "%s", commuAddress);
    // entry->commuAddress_len = commuAddress_len;

    // snprintf(entry->commuAddress, sizeof(entry->commuAddress), "%s", commuAddress);
    // entry->commuAddress_len = commuAddress_len;

    entry->next = ieeeP1451Table_head;
    ieeeP1451Table_head = entry;
    return entry;
}

/* remove a row from the table */
void
ieeeP1451Table_removeEntry( struct ieeeP1451Table_entry *entry ) {
    struct ieeeP1451Table_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = ieeeP1451Table_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        ieeeP1451Table_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}

#define STRMAX 1024

/* Example cache handling - set up linked list from a suitable file */
int
ieeeP1451Table_load( netsnmp_cache *cache, void *vmagic ) {
    FILE *fp;
    struct ieeeP1451Table_entry *this;
    char buf[STRMAX];

    /* The basic load routine template assumes that the data to
       be reported is held in a file - with one row of the file
       for each row of the table.
          If your data is available via a different API, you
       should amend this initial block (and the control of the
       'while' loop) accordingly.
          'XXX' marks where the template is incomplete and
       code will definitely need to be added. */

    fp = fopen( "/data/for/ieeeP1451Table", "r" );
    if ( !fp ) {
        return -1;
    }
    while ( fgets( buf, STRMAX, fp )) {
        this = SNMP_MALLOC_TYPEDEF( struct ieeeP1451Table_entry );
        /* XXX - Unpick 'buf' to extract the individual field values
                 and then populate the 'this' data structure with them */

        this->next = ieeeP1451Table_head;
        ieeeP1451Table_head = this;    /* Iterate helper is fine with unordered lists! */
    }
    fclose(fp);
    return 0;  /* OK */
}

void
ieeeP1451Table_free( netsnmp_cache *cache, void *vmagic ) {
    struct ieeeP1451Table_entry *this, *that;

    for ( this = ieeeP1451Table_head; this; this=that ) {
        that = this->next;
        SNMP_FREE( this );   /* XXX - release any other internal resources */
    }
    ieeeP1451Table_head = NULL;
}

/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
ieeeP1451Table_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = ieeeP1451Table_head;
    return ieeeP1451Table_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
ieeeP1451Table_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct ieeeP1451Table_entry *entry = (struct ieeeP1451Table_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->timID );
        idx = idx->next_variable;
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->channelID );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the ieeeP1451Table table */
int
ieeeP1451Table_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct ieeeP1451Table_entry          *table_entry;
    struct userTable_entry *table_row;
    int ret;

    DEBUGMSGTL(("ieeeP1451Project2:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451Table_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_TIMID:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                // printf("%ld\n", table_entry->channelID);
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->timID);
                break;
            case COLUMN_CHANNELID:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->channelID);
                break;
            case COLUMN_COMMUTYPE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->commuType,
                                          table_entry->commuType_len);
                break;
            case COLUMN_COMMUADDRESS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->commuAddress,
                                          table_entry->commuAddress_len);
                break;
            case COLUMN_TESTVALUE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->testValue,
                                          table_entry->testValue_len);
                break;
            case COLUMN_P1451ROWSTATUS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->p1451RowStatus);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;


        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
    
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451Table_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_COMMUTYPE:
	        /* or possibly 'netsnmp_check_vb_type_and_size' */
                ret = netsnmp_check_vb_type_and_max_size(
                          request->requestvb, ASN_OCTET_STR, sizeof(table_entry->commuType));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_COMMUADDRESS:
	        /* or possibly 'netsnmp_check_vb_type_and_size' */
                ret = netsnmp_check_vb_type_and_max_size(
                          request->requestvb, ASN_OCTET_STR, sizeof(table_entry->commuAddress));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_P1451ROWSTATUS:
                ret = netsnmp_check_vb_rowstatus(request->requestvb,
                         (table_entry ? RS_ACTIVE : RS_NONEXISTENT ));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error( reqinfo, request,
                                           SNMP_ERR_NOTWRITABLE );
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
    
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451Table_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_P1451ROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                case RS_CREATEANDWAIT:
                    table_row = ieeeP1451Table_createEntry(
                        *table_info->indexes->val.integer
                        , *table_info->indexes->next_variable->val.integer
                        );
                    if (table_row) {
                        netsnmp_insert_iterator_context( request, table_row );
                    } else {
                        netsnmp_set_request_error( reqinfo, request,
                                                   SNMP_ERR_RESOURCEUNAVAILABLE );
                        return SNMP_ERR_NOERROR;
                    }
                }
            }
        }
        break;

    case MODE_SET_FREE:
    printf("save3\n");
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451Table_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_P1451ROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                case RS_CREATEANDWAIT:
                    if (table_entry && !table_entry->valid) {
                        ieeeP1451Table_removeEntry(table_row );
                    }
                }
            }
        }
        break;

    case MODE_SET_ACTION:
    printf("save4\n");
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451Table_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_COMMUTYPE:
                memcpy( table_entry->old_commuType,
                        table_entry->commuType,
                        sizeof(table_entry->commuType));
                table_entry->old_commuType_len =
                        table_entry->commuType_len;
                memset( table_entry->commuType, 0,
                        sizeof(table_entry->commuType));
                memcpy( table_entry->commuType,
                        request->requestvb->val.string,
                        request->requestvb->val_len);
                table_entry->commuType_len =
                        request->requestvb->val_len;
                break;
            case COLUMN_COMMUADDRESS:
                memcpy( table_entry->old_commuAddress,
                        table_entry->commuAddress,
                        sizeof(table_entry->commuAddress));
                table_entry->old_commuAddress_len =
                        table_entry->commuAddress_len;
                memset( table_entry->commuAddress, 0,
                        sizeof(table_entry->commuAddress));
                memcpy( table_entry->commuAddress,
                        request->requestvb->val.string,
                        request->requestvb->val_len);
                table_entry->commuAddress_len =
                        request->requestvb->val_len;
                break;
            }
        }
        /* Check the internal consistency of an active row */
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451Table_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_P1451ROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_ACTIVE:
                case RS_CREATEANDGO:
                    if (0/* XXX */) {
                        netsnmp_set_request_error( reqinfo, request,
                                                   SNMP_ERR_INCONSISTENTVALUE );
                        return SNMP_ERR_NOERROR;
                    }
                }
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451Table_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_COMMUTYPE:
                memcpy( table_entry->commuType,
                        table_entry->old_commuType,
                        sizeof(table_entry->commuType));
                memset( table_entry->old_commuType, 0,
                        sizeof(table_entry->commuType));
                table_entry->commuType_len =
                        table_entry->old_commuType_len;
                break;
            case COLUMN_COMMUADDRESS:
                memcpy( table_entry->commuAddress,
                        table_entry->old_commuAddress,
                        sizeof(table_entry->commuAddress));
                memset( table_entry->old_commuAddress, 0,
                        sizeof(table_entry->commuAddress));
                table_entry->commuAddress_len =
                        table_entry->old_commuAddress_len;
                break;
            case COLUMN_P1451ROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                case RS_CREATEANDWAIT:
                    if (table_entry && !table_entry->valid) {
                        ieeeP1451Table_removeEntry(table_row );
                    }
                }
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451Table_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_P1451ROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                    table_entry->valid = 1;
                    /* Fall-through */
                case RS_ACTIVE:
                    table_entry->p1451RowStatus = RS_ACTIVE;
                    break;

                case RS_CREATEANDWAIT:
                    table_entry->valid = 1;
                    /* Fall-through */
                case RS_NOTINSERVICE:
                    table_entry->p1451RowStatus = RS_NOTINSERVICE;
                    break;

                case RS_DESTROY:
                    ieeeP1451Table_removeEntry(table_entry);
                }
            }
        }
        break;
    }
    return SNMP_ERR_NOERROR;
}