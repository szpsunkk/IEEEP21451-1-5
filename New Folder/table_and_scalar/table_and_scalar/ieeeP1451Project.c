/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "ieeeP1451Project.h"

#include <Python.h>
#include <stdarg.h>

unsigned char buf[1024];

/* for acceptable `arg_format' `ret_val_format', see https://docs.python.org/2.7/c-api/arg.html */
int int_py_caller(char *python_module_name, char *python_func_name, char *arg_format, char *ret_val_format, ...)
{
  PyObject *python_module_object    = NULL;
  PyObject *python_arg_object   = NULL;
  PyObject *python_func_object    = NULL;
  PyObject *python_return_val_object  = NULL;

  va_list vl; /* this is used to parse the arguments in the `...' part. see stdarg(3) */

  Py_Initialize();

  /* these two lines are required, if any custom module under the current working dirctory is to be loaded */
  PyRun_SimpleString("import sys");
  PyRun_SimpleString("sys.path.append('.')");

  python_module_object = PyImport_ImportModule(python_module_name); 
  if (!python_module_object) {
    printf("Error: cannot import module.\n");
    // return 0; // TODO:
  }

  python_func_object = PyObject_GetAttrString(python_module_object, python_func_name);
  if (!python_func_object) {
    printf("Error: cannot import function.\n");
    // return 0; // TODO:
  }

  /* start parsing arguments */
  va_start(vl, ret_val_format);
  /* construct arguments for the python function using the arguments passed to this C function */
  python_arg_object = Py_VaBuildValue(arg_format, vl);
  if (!python_arg_object) {
    printf("Error: cannot construct arguments.\n");
    // return 0; // TODO:
  }
  /* finish parsing arguments */
  va_end(vl);

  // PyObject_Print(python_arg_object, stdout, 0/*Py_PRINT_RAW*/); /* the 3rd arg controls either using `str()' or `repr()' */
  // printf("\n");


  /* `python_arg_object' should be a tuple */
  python_return_val_object = PyEval_CallObject(python_func_object, python_arg_object);
  if (!python_return_val_object) {
    printf("Error: function not called successfully.\n");
    // return 0; // TODO:
  }

  // TODO: another function? use tuple or not? what if multiple return value?
  // after experiemnt, PyArg_Parse can't use tuple
  if (!PyArg_Parse(python_return_val_object, ret_val_format, buf)) {
    printf("Error: cannot parse return value.\n");
    // return 0; // TODO:
  }

  // TODO: unified way of handling types
  printf("%d\n", *((int *) buf));

  Py_DECREF(python_module_object);
  Py_DECREF(python_func_object);
  Py_DECREF(python_arg_object);
  Py_DECREF(python_return_val_object);

  return *((int *) buf);
}

/* STARTS */

#include  <stdlib.h>
#include  <time.h>

#define   TEMPERATURE_FLUCTUATION   2
#define   LIGHT_FLUCTUATION   4
#define   LCD_STRING_MAX_LEN    10240

long  value_of_temperature;
long  value_of_light;
long  base_value_of_temperature   = 140;
long  base_value_of_light     = 120;
long  gain_value_of_light_when_lamp_on  = 60;
long  status_of_lamp        = 0;
long  status_of_humdifier     = 0;
char  lcd_display_string[LCD_STRING_MAX_LEN]  = "Good morning!";
int lcd_display_string_len      = 13;

long  value_of_Temperature;
long  value_of_Light;
long  value_of_Humidity;
long  value_of_Distence;
long  value_of_Accelerationx;
long  value_of_Accelerationy;
long  value_of_Accelerationz;
long  value_of_HS;
long  value_of_LoadVoltage;
long  value_of_LoadCurrent;
long  value_of_LoadPower;
long  value_of_Pressure;
long  value_of_seFree1;
long  value_of_seFree2;
long  value_of_Lamp;
long  value_of_Hunidifier;
long  value_of_buzzer;
long  value_of_LEDScreen;
long  value_of_acFree1;
long  value_of_acFree2;

long
randl(long max)
{
  return ((long) rand()) % max;
}

/* ENDS*/

/*table*/
#define NNN 256
#define STRMAX 1024

/*table*/

/** Initializes the ieeeP1451Project module */
void
init_ieeeP1451Project(void)
{
    const oid SeTemperature_oid[] = { 1,3,6,1,4,1,7934,1451,1,1 };
    const oid SeLight_oid[] = { 1,3,6,1,4,1,7934,1451,1,2 };
    const oid SeHumidity_oid[] = { 1,3,6,1,4,1,7934,1451,1,3 };
    const oid SeDistence_oid[] = { 1,3,6,1,4,1,7934,1451,1,4 };
    const oid SeAccelerationx_oid[] = { 1,3,6,1,4,1,7934,1451,1,5 };
    const oid SeAccelerationy_oid[] = { 1,3,6,1,4,1,7934,1451,1,6 };
    const oid SeAccelerationz_oid[] = { 1,3,6,1,4,1,7934,1451,1,7 };
    const oid SeHS_oid[] = { 1,3,6,1,4,1,7934,1451,1,8 };
    const oid SeLoadVoltage_oid[] = { 1,3,6,1,4,1,7934,1451,1,9 };
    const oid SeLoadCurrent_oid[] = { 1,3,6,1,4,1,7934,1451,1,10 };
    const oid SeLoadPower_oid[] = { 1,3,6,1,4,1,7934,1451,1,11 };
    const oid SePressure_oid[] = { 1,3,6,1,4,1,7934,1451,1,12 };
    const oid SeFree1_oid[] = { 1,3,6,1,4,1,7934,1451,1,13 };
    const oid SeFree2_oid[] = { 1,3,6,1,4,1,7934,1451,1,14 };
    const oid AcLamp_oid[] = { 1,3,6,1,4,1,7934,1451,2,1 };
    const oid AcHunidifier_oid[] = { 1,3,6,1,4,1,7934,1451,2,2 };
    const oid Acbuzzer_oid[] = { 1,3,6,1,4,1,7934,1451,2,3 };
    const oid AcLEDScreen_oid[] = { 1,3,6,1,4,1,7934,1451,2,4 };
    const oid AcFree1_oid[] = { 1,3,6,1,4,1,7934,1451,2,5 };
    const oid AcFree2_oid[] = { 1,3,6,1,4,1,7934,1451,2,6 };
    initialize_table_ieeeP1451TimTable();

  DEBUGMSGTL(("ieeeP1451Project", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeTemperature", handle_SeTemperature,
                               SeTemperature_oid, OID_LENGTH(SeTemperature_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeLight", handle_SeLight,
                               SeLight_oid, OID_LENGTH(SeLight_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeHumidity", handle_SeHumidity,
                               SeHumidity_oid, OID_LENGTH(SeHumidity_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeDistence", handle_SeDistence,
                               SeDistence_oid, OID_LENGTH(SeDistence_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeAccelerationx", handle_SeAccelerationx,
                               SeAccelerationx_oid, OID_LENGTH(SeAccelerationx_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeAccelerationy", handle_SeAccelerationy,
                               SeAccelerationy_oid, OID_LENGTH(SeAccelerationy_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeAccelerationz", handle_SeAccelerationz,
                               SeAccelerationz_oid, OID_LENGTH(SeAccelerationz_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeHS", handle_SeHS,
                               SeHS_oid, OID_LENGTH(SeHS_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeLoadVoltage", handle_SeLoadVoltage,
                               SeLoadVoltage_oid, OID_LENGTH(SeLoadVoltage_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeLoadCurrent", handle_SeLoadCurrent,
                               SeLoadCurrent_oid, OID_LENGTH(SeLoadCurrent_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeLoadPower", handle_SeLoadPower,
                               SeLoadPower_oid, OID_LENGTH(SeLoadPower_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SePressure", handle_SePressure,
                               SePressure_oid, OID_LENGTH(SePressure_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeFree1", handle_SeFree1,
                               SeFree1_oid, OID_LENGTH(SeFree1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SeFree2", handle_SeFree2,
                               SeFree2_oid, OID_LENGTH(SeFree2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("AcLamp", handle_AcLamp,
                               AcLamp_oid, OID_LENGTH(AcLamp_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("AcHunidifier", handle_AcHunidifier,
                               AcHunidifier_oid, OID_LENGTH(AcHunidifier_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("Acbuzzer", handle_Acbuzzer,
                               Acbuzzer_oid, OID_LENGTH(Acbuzzer_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("AcLEDScreen", handle_AcLEDScreen,
                               AcLEDScreen_oid, OID_LENGTH(AcLEDScreen_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("AcFree1", handle_AcFree1,
                               AcFree1_oid, OID_LENGTH(AcFree1_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("AcFree2", handle_AcFree2,
                               AcFree2_oid, OID_LENGTH(AcFree2_oid),
                               HANDLER_CAN_RWRITE
        ));
}

int
handle_SeTemperature(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          /* STARTS */
          value_of_Temperature = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 10);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Temperature,
                                           (size_t) 8);
          /* ENDS */
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeTemperature\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeLight(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          /* STARTS */
          value_of_Light = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 11);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Light,
                                           (size_t) 8);
          /* ENDS */
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeLight\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeHumidity(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          /* STARTS */
          value_of_Humidity = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 12);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Humidity,
                                           (size_t) 8);
          /* ENDS */
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeHumidity\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeDistence(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          /* STARTS */
          value_of_Distence = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 13);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Distence,
                                           (size_t) 8);
          /* ENDS */
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeDistence\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeAccelerationx(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          /* STARTS */
          value_of_Accelerationx = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 14);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Accelerationx,
                                           (size_t) 8);
          /* ENDS */
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeAccelerationx\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeAccelerationy(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          /* STARTS */
          value_of_Accelerationy = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 15);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Accelerationy,
                                           (size_t) 8);
          /* ENDS */
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeAccelerationy\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeAccelerationz(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          /* STARTS */
          value_of_Accelerationz = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 16);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Accelerationz,
                                           (size_t) 8);
          /* ENDS */
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeAccelerationz\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeHS(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          /* STARTS */
          value_of_HS = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 17);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_HS,
                                           (size_t) 8);
          /* ENDS */
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeHS\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeLoadVoltage(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          /* STARTS */
          value_of_LoadVoltage = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 18);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_LoadVoltage,
                                           (size_t) 8);
          /* ENDS */
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeLoadVoltage\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeLoadCurrent(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          /* STARTS */
          value_of_LoadCurrent = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 19);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_LoadCurrent,
                                           (size_t) 8);
          /* ENDS */
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeLoadCurrent\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeLoadPower(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          /* STARTS */
          value_of_LoadPower = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 110);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_LoadPower,
                                           (size_t) 8);
          /* ENDS */
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeLoadPower\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SePressure(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          /* STARTS */
          value_of_Pressure = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 111);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Pressure,
                                           (size_t) 8);
          /* ENDS */
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SePressure\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeFree1(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          /* STARTS */
          value_of_seFree1 = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 112);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_seFree1,
                                           (size_t) 8);
          /* ENDS */
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeFree1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SeFree2(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          /* STARTS */
          value_of_seFree2 = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 113);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_seFree2,
                                           (size_t) 8);
          /* ENDS */
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SeFree2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_AcLamp(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          /* STARTS */
          value_of_Lamp = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 20);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Lamp,
                                           (size_t) 8);
          /* ENDS */
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //     /* XXX malloc "undo" storage buffer */
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
              /* STARTS */
              value_of_Lamp = *(requests->requestvb->val.integer);
              if (value_of_Lamp)
                value_of_Lamp = 1;
              int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 20, value_of_Lamp);
              /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_AcLamp\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_AcHunidifier(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          /* STARTS */
          value_of_Hunidifier = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 21);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_Hunidifier,
                                           (size_t) 8);
          /* ENDS */
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //      XXX malloc "undo" storage buffer 
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
              /* STARTS */
              value_of_Hunidifier = *(requests->requestvb->val.integer);
              if (value_of_Hunidifier)
                value_of_Hunidifier = 1;
              int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 21, value_of_Hunidifier);
              /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_AcHunidifier\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_Acbuzzer(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          /* STARTS */
          value_of_buzzer = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 22);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_buzzer,
                                           (size_t) 8);
          /* ENDS */
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //      XXX malloc "undo" storage buffer 
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
              /* STARTS */
              value_of_buzzer = *(requests->requestvb->val.integer);
              if (value_of_buzzer)
                value_of_buzzer = 1;
              int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 22, value_of_buzzer);
              /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_Acbuzzer\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_AcLEDScreen(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          /* STARTS */
          value_of_LEDScreen = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 23);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_LEDScreen,
                                           (size_t) 8);
          /* ENDS */
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //      XXX malloc "undo" storage buffer 
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
              /* STARTS */
              value_of_LEDScreen = *(requests->requestvb->val.integer);
              if (value_of_LEDScreen)
                value_of_LEDScreen = 1;
              int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 23, value_of_LEDScreen);
              /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_AcLEDScreen\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_AcFree1(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          /* STARTS */
          value_of_acFree1 = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 24);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_acFree1,
                                           (size_t) 8);
          /* ENDS */
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //      XXX malloc "undo" storage buffer 
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
              /* STARTS */
              value_of_acFree1 = *(requests->requestvb->val.integer);
              if (value_of_acFree1)
                value_of_acFree1 = 1;
              int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 24, value_of_acFree1);
              /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_AcFree1\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_AcFree2(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
          /* STARTS */
          value_of_acFree1 = int_py_caller("ieeeP1451Command", "get_int", "(i)", "i", 25);
          // value_of_temperature = base_value_of_temperature 
          //                      + randl(TEMPERATURE_FLUCTUATION)
          //                      - TEMPERATURE_FLUCTUATION / 2;
                  snmp_set_var_typed_value(requests->requestvb,
                                           ASN_INTEGER,
                                           &value_of_acFree1,
                                           (size_t) 8);
          /* ENDS */
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        // case MODE_SET_RESERVE1:
        //         /* or you could use netsnmp_check_vb_type_and_size instead */
        //     ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        //     if ( ret != SNMP_ERR_NOERROR ) {
        //         netsnmp_set_request_error(reqinfo, requests, ret );
        //     }
        //     break;

        // case MODE_SET_RESERVE2:
        //      XXX malloc "undo" storage buffer 
        //     if (/* XXX if malloc, or whatever, failed: */) {
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        //     }
        //     break;

        // case MODE_SET_FREE:
        //     /* XXX: free resources allocated in RESERVE1 and/or
        //        RESERVE2.  Something failed somewhere, and the states
        //        below won't be called. */
        //     break;

        case MODE_SET_ACTION:
              /* STARTS */
              value_of_acFree1 = *(requests->requestvb->val.integer);
              if (value_of_acFree1)
                value_of_acFree1 = 1;
              int_py_caller("ieeeP1451Command", "set_int", "(ii)", "i", 25, value_of_acFree1);
              /* ENDS */
            break;

        // case MODE_SET_COMMIT:
        //     /* XXX: delete temporary storage */
        //     if (/* XXX: error? */) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        //     }
        //     break;

        // case MODE_SET_UNDO:
        //     /* XXX: UNDO and return to previous value for the object */
        //     if ( XXX: error? ) {
        //         /* try _really_really_ hard to never get to this point */
        //         netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        //     }
        //     break;

        // default:
        //     /* we should never get here, so this is a really bad error */
        //     snmp_log(LOG_ERR, "unknown mode (%d) in handle_AcFree2\n", reqinfo->mode );
        //     return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




/*table begin*/
void
initialize_table_ieeeP1451TimTable(void)
{
    const oid ieeeP1451TimTable_oid[] = {1,3,6,1,4,1,7934,1451,5};
    const size_t ieeeP1451TimTable_oid_len   = OID_LENGTH(ieeeP1451TimTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("ieeeP1451Project:init", "initializing table ieeeP1451TimTable\n"));

    reg = netsnmp_create_handler_registration(
              "ieeeP1451TimTable",     ieeeP1451TimTable_handler,
              ieeeP1451TimTable_oid, ieeeP1451TimTable_oid_len,
              HANDLER_CAN_RWRITE
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: timID */
                           ASN_INTEGER,  /* index: channelID */
                           0);
    table_info->min_column = COLUMN_TIMID;
    table_info->max_column = COLUMN_P1451ROWSTATUS;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = ieeeP1451TimTable_get_first_data_point;
    iinfo->get_next_data_point  = ieeeP1451TimTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
}

    /* Typical data structure for a row entry */
struct ieeeP1451TimTable_entry {
    /* Index values */
    long timID;
    long channelID;

    /* Column values */
    // long timID;
    long old_timID;
    // long channelID;
    long old_channelID;
    char commuType[NNN];
    size_t commuType_len;
    char old_commuType[NNN];
    size_t old_commuType_len;
    char commuAddress[NNN];
    size_t commuAddress_len;
    char old_commuAddress[NNN];
    size_t old_commuAddress_len;
    char testValue[NNN];
    size_t testValue_len;
    char old_testValue[NNN];
    size_t old_testValue_len;
    long p1451RowStatus;
    long old_p1451RowStatus;

    /* Illustrate using a simple linked list */
    int   valid;
    struct ieeeP1451TimTable_entry *next;
};

struct ieeeP1451TimTable_entry  *ieeeP1451TimTable_head;

/* create a new row in the (unsorted) table */
struct ieeeP1451TimTable_entry *
ieeeP1451TimTable_createEntry(
                 long  timID,
                 long  channelID
                ) {
    struct ieeeP1451TimTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct ieeeP1451TimTable_entry);
    if (!entry)
        return NULL;

    entry->timID = timID;
    entry->channelID = channelID;


    entry->next = ieeeP1451TimTable_head;
    ieeeP1451TimTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
ieeeP1451TimTable_removeEntry( struct ieeeP1451TimTable_entry *entry ) {
    struct ieeeP1451TimTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = ieeeP1451TimTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        ieeeP1451TimTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}


/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
ieeeP1451TimTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = ieeeP1451TimTable_head;
    return ieeeP1451TimTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
ieeeP1451TimTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct ieeeP1451TimTable_entry *entry = (struct ieeeP1451TimTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->timID );
        idx = idx->next_variable;
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->channelID );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the ieeeP1451TimTable table */
long value_of_P1451ROWSTATUS;

int
ieeeP1451TimTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct ieeeP1451TimTable_entry          *table_entry;
    struct userTable_entry *table_row;
    int ret;
    DEBUGMSGTL(("ieeeP1451Project:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451TimTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_TIMID:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->timID);
                break;
            case COLUMN_CHANNELID:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->channelID);
                break;
            case COLUMN_COMMUTYPE:
                //printf("set function type 3" );
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->commuType,
                                          table_entry->commuType_len);
                break;
            case COLUMN_COMMUADDRESS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->commuAddress,
                                          table_entry->commuAddress_len);
                break;
            case COLUMN_TESTVALUE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }

                table_entry->testValue = int_py_caller("ieeeP1451Command", "set_channel", "(iii)", "i", *table_info->indexes->val.integer, *table_info->indexes->next_variable->val.integer, 0);
                // snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                //                              &value_of_P1451ROWSTATUS);
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->testValue,
                                          table_entry->testValue_len);
                break;
            case COLUMN_P1451ROWSTATUS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                //printf("get function");
                
                // value_of_P1451ROWSTATUS = int_py_caller("ieeeP1451Command", "set_channel", "(iii)", "i", *table_info->indexes->val.integer, *table_info->indexes->next_variable->val.integer, 0);
                // snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                //                              &value_of_P1451ROWSTATUS);
                //printf("table_entry->p1451RowStatus%d\n", table_entry->p1451RowStatus);
                //printf("request->requestvb%d\n", request->requestvb);

              
                  // snmp_set_var_typed_value(requests->requestvb,
                  //                          ASN_INTEGER,
                  //                          &value_of_P1451ROWSTATUS,
                  //                          (size_t) 8);
          /* ENDS */
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451TimTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_TIMID:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CHANNELID:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_COMMUTYPE:
          /* or possibly 'netsnmp_check_vb_type_and_size' */
                //printf("set function type s 4" );
                ret = netsnmp_check_vb_type_and_max_size(
                          request->requestvb, ASN_OCTET_STR, sizeof(table_entry->commuType));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_COMMUADDRESS:
          /* or possibly 'netsnmp_check_vb_type_and_size' */
                ret = netsnmp_check_vb_type_and_max_size(
                          request->requestvb, ASN_OCTET_STR, sizeof(table_entry->commuAddress));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_TESTVALUE:
          /* or possibly 'netsnmp_check_vb_type_and_size' */

                // value_of_P1451ROWSTATUS = int_py_caller("ieeeP1451Command", "set_channel", "(iii)", "i", *table_info->indexes->val.integer, *table_info->indexes->next_variable->val.integer, *(requests->requestvb->val.integer));
                // snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                //                              value_of_P1451ROWSTATUS);
                ret = netsnmp_check_vb_type_and_max_size(
                          request->requestvb, ASN_OCTET_STR, sizeof(table_entry->testValue));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_P1451ROWSTATUS:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error( reqinfo, request,
                                           SNMP_ERR_NOTWRITABLE );
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:  // set 应该是注册功能
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451TimTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_TIMID:
            case COLUMN_CHANNELID:
            case COLUMN_COMMUTYPE:
            case COLUMN_COMMUADDRESS:
            case COLUMN_TESTVALUE:
            case COLUMN_P1451ROWSTATUS:
                if ( !table_row ) {
                    table_row = ieeeP1451TimTable_createEntry(
                         *table_info->indexes->val.integer
                        , *table_info->indexes->next_variable->val.integer
                        );

                    //int_py_caller("ieeeP1451Command", "set_channel", "(iii)", "i", *table_info->indexes->val.integer, *table_info->indexes->next_variable->val.integer, *(requests->requestvb->val.integer));
                    //printf("set function for P1451ROWSTATUS");
                    //printf("ssssssssss%d\n", *table_info->indexes->next_variable->val.integer);   //channelId
                    //printf("dddddddddddd%d\n", *table_info->indexes->val.integer);      //timId
                    //printf("eeeeeeeeeeeee%d\n", *(requests->requestvb->val.integer));   //数值
                    if (table_row) {
                        netsnmp_insert_iterator_context( request, table_row );
                    } else {
                        netsnmp_set_request_error( reqinfo, request,
                                                   SNMP_ERR_RESOURCEUNAVAILABLE );
                        return SNMP_ERR_NOERROR;
                    }
                }
                break;
            }
        }
        break;

    case MODE_SET_FREE:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451TimTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_TIMID:
            case COLUMN_CHANNELID:
            case COLUMN_COMMUTYPE:
            case COLUMN_COMMUADDRESS:
            case COLUMN_TESTVALUE:
            case COLUMN_P1451ROWSTATUS:
                if ( table_entry && !table_entry->valid ) {
                    ieeeP1451TimTable_removeEntry(table_entry );
                }
                break;
            }
        }
        break;

    case MODE_SET_ACTION:  // set具体操作功能
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451TimTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_TIMID:
                table_entry->old_timID = table_entry->timID;
                table_entry->timID     = *request->requestvb->val.integer;
                break;
            case COLUMN_CHANNELID:
                table_entry->old_channelID = table_entry->channelID;
                table_entry->channelID     = *request->requestvb->val.integer;
                break;
            case COLUMN_COMMUTYPE:
                //printf("set function type s 1");
                memcpy( table_entry->old_commuType,
                        table_entry->commuType,
                        sizeof(table_entry->commuType));
                table_entry->old_commuType_len =
                        table_entry->commuType_len;
                memset( table_entry->commuType, 0,
                        sizeof(table_entry->commuType));
                memcpy( table_entry->commuType,
                        request->requestvb->val.string,
                        request->requestvb->val_len);
                table_entry->commuType_len =
                        request->requestvb->val_len;
                break;
            case COLUMN_COMMUADDRESS:
                memcpy( table_entry->old_commuAddress,
                        table_entry->commuAddress,
                        sizeof(table_entry->commuAddress));
                table_entry->old_commuAddress_len =
                        table_entry->commuAddress_len;
                memset( table_entry->commuAddress, 0,
                        sizeof(table_entry->commuAddress));
                memcpy( table_entry->commuAddress,
                        request->requestvb->val.string,
                        request->requestvb->val_len);
                table_entry->commuAddress_len =
                        request->requestvb->val_len;
                break;
            case COLUMN_TESTVALUE:
                // memcpy( table_entry->old_testValue,
                //         table_entry->testValue,
                //         sizeof(table_entry->testValue));
                // table_entry->old_testValue_len =
                //         table_entry->testValue_len;
                // memset( table_entry->testValue, 0,
                //         sizeof(table_entry->testValue));
                // memcpy( table_entry->testValue,
                //         request->requestvb->val.string,
                //         request->requestvb->val_len);
                // table_entry->testValue_len =
                //         request->requestvb->val_len;
                table_entry->testValue = int_py_caller("ieeeP1451Command", "set_channel", "(iii)", "i", *table_info->indexes->val.integer, *table_info->indexes->next_variable->val.integer, *(requests->requestvb->val.integer));
                // snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                //                              &value_of_P1451ROWSTATUS);
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->testValue,
                                          table_entry->testValue_len);

                break;
            case COLUMN_P1451ROWSTATUS:
                table_entry->old_p1451RowStatus = table_entry->p1451RowStatus;
                table_entry->p1451RowStatus     = *request->requestvb->val.integer;
                
                // printf("p1451RowStatus%d\n", table_entry->p1451RowStatus);
                // printf("*request->requestvb->val.integer%d\n", *request->requestvb->val.integer);
                break;
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451TimTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_TIMID:
                if ( table_entry && !table_entry->valid ) {
                    ieeeP1451TimTable_removeEntry(table_entry );
                } else {
                    table_entry->timID     = table_entry->old_timID;
                    table_entry->old_timID = 0;
                }
                break;
            case COLUMN_CHANNELID:
                if ( table_entry && !table_entry->valid ) {
                    ieeeP1451TimTable_removeEntry(table_entry );
                } else {
                    table_entry->channelID     = table_entry->old_channelID;
                    table_entry->old_channelID = 0;
                }
                break;
            case COLUMN_COMMUTYPE:
                //printf("set function type s 2" );
                if ( table_entry && !table_entry->valid ) {
                    ieeeP1451TimTable_removeEntry(table_entry );
                } else {
                    memcpy( table_entry->commuType,
                            table_entry->old_commuType,
                            sizeof(table_entry->commuType));
                    memset( table_entry->old_commuType, 0,
                            sizeof(table_entry->commuType));
                    table_entry->commuType_len =
                            table_entry->old_commuType_len;
                }
                break;
            case COLUMN_COMMUADDRESS:
                if ( table_entry && !table_entry->valid ) {
                    ieeeP1451TimTable_removeEntry(table_entry);
                } else {
                    memcpy( table_entry->commuAddress,
                            table_entry->old_commuAddress,
                            sizeof(table_entry->commuAddress));
                    memset( table_entry->old_commuAddress, 0,
                            sizeof(table_entry->commuAddress));
                    table_entry->commuAddress_len =
                            table_entry->old_commuAddress_len;
                }
                break;
            case COLUMN_TESTVALUE:
                if ( table_entry && !table_entry->valid ) {
                    ieeeP1451TimTable_removeEntry(table_entry);
                } else {
                    memcpy( table_entry->testValue,
                            table_entry->old_testValue,
                            sizeof(table_entry->testValue));
                    memset( table_entry->old_testValue, 0,
                            sizeof(table_entry->testValue));
                    table_entry->testValue_len =
                            table_entry->old_testValue_len;
                }
                break;
            case COLUMN_P1451ROWSTATUS:
                if ( table_entry && !table_entry->valid ) {
                    ieeeP1451TimTable_removeEntry(table_entry );
                } else {
                    table_entry->p1451RowStatus     = table_entry->old_p1451RowStatus;
                    table_entry->old_p1451RowStatus = 0;
                }
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451TimTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_TIMID:
            case COLUMN_CHANNELID:
            case COLUMN_COMMUTYPE:
            case COLUMN_COMMUADDRESS:
            case COLUMN_TESTVALUE:
            case COLUMN_P1451ROWSTATUS:
                if ( table_entry && !table_entry->valid ) {
                    table_entry->valid = 1;
                }
            }
        }
        break;
    }
    return SNMP_ERR_NOERROR;
}
/*table end*/