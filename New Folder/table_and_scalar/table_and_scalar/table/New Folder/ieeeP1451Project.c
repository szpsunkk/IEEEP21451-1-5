/*
 * Note: this file originally auto-generated by mib2c using
 *  $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "ieeeP1451Project.h"

/** Initializes the ieeeP1451Project module */
void
init_ieeeP1451Project(void)
{
  /* here we initialize all the tables we're planning on supporting */
    initialize_table_ieeeP1451TimTable();
}

 // # Determine the first/last column names

/** Initialize the ieeeP1451TimTable table by defining its contents and how it's structured */
void
initialize_table_ieeeP1451TimTable(void)
{
    const oid ieeeP1451TimTable_oid[] = {1,3,6,1,4,1,7934,1451,5};
    const size_t ieeeP1451TimTable_oid_len   = OID_LENGTH(ieeeP1451TimTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("ieeeP1451Project:init", "initializing table ieeeP1451TimTable\n"));

    reg = netsnmp_create_handler_registration(
              "ieeeP1451TimTable",     ieeeP1451TimTable_handler,
              ieeeP1451TimTable_oid, ieeeP1451TimTable_oid_len,
              HANDLER_CAN_RWRITE
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: timID */
                           ASN_INTEGER,  /* index: channelID */
                           0);
    table_info->min_column = COLUMN_TIMID;
    table_info->max_column = COLUMN_P1451ROWSTATUS;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = ieeeP1451TimTable_get_first_data_point;
    iinfo->get_next_data_point  = ieeeP1451TimTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );
    netsnmp_inject_handler_before( reg, 
        netsnmp_get_cache_handler(IEEEP1451TIMTABLE_TIMEOUT,
                                  ieeeP1451TimTable_load, ieeeP1451TimTable_free,
                                  ieeeP1451TimTable_oid, ieeeP1451TimTable_oid_len),
            TABLE_ITERATOR_NAME);

    /* Initialise the contents of the table here */
}
# define NNN 256
    /* Typical data structure for a row entry */
struct ieeeP1451TimTable_entry {
    /* Index values */
    //long timID;
    //long channelID;

    /* Column values */
    long timID;
    long old_timID;
    long channelID;
    long old_channelID;
    char commuType[NNN];
    size_t commuType_len;
    char old_commuType[NNN];
    size_t old_commuType_len;
    char commuAddress[NNN];
    size_t commuAddress_len;
    char old_commuAddress[NNN];
    size_t old_commuAddress_len;
    char testValue[NNN];
    size_t testValue_len;
    char old_testValue[NNN];
    size_t old_testValue_len;
     long p1451RowStatus;
     long old_p1451RowStatus;

    /* Illustrate using a simple linked list */
    int   valid;
    struct ieeeP1451TimTable_entry *next;
};

struct ieeeP1451TimTable_entry  *ieeeP1451TimTable_head;

/* create a new row in the (unsorted) table */
struct ieeeP1451TimTable_entry *
ieeeP1451TimTable_createEntry(
                 long  timID,
                 long  channelID
                ) {
    struct ieeeP1451TimTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct ieeeP1451TimTable_entry);
    if (!entry)
        return NULL;

    entry->timID = timID;
    entry->channelID = channelID;
    entry->next = ieeeP1451TimTable_head;
    ieeeP1451TimTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
ieeeP1451TimTable_removeEntry( struct ieeeP1451TimTable_entry *entry ) {
    struct ieeeP1451TimTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = ieeeP1451TimTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        ieeeP1451TimTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}

/* Example cache handling - set up linked list from a suitable file */
# define STRMAX 1024
int
ieeeP1451TimTable_load( netsnmp_cache *cache, void *vmagic ) {
    FILE *fp;
    struct ieeeP1451TimTable_entry *this;
    char buf[STRMAX];

    /* The basic load routine template assumes that the data to
       be reported is held in a file - with one row of the file
       for each row of the table.
          If your data is available via a different API, you
       should amend this initial block (and the control of the
       'while' loop) accordingly.
          'XXX' marks where the template is incomplete and
       code will definitely need to be added. */

    fp = fopen( "/data/for/ieeeP1451TimTable", "r" );
    if ( !fp ) {
        return -1;
    }
    while ( fgets( buf, STRMAX, fp )) {
        this = SNMP_MALLOC_TYPEDEF( struct ieeeP1451TimTable_entry );
        /* XXX - Unpick 'buf' to extract the individual field values
                 and then populate the 'this' data structure with them */

        this->next = ieeeP1451TimTable_head;
        ieeeP1451TimTable_head = this;    /* Iterate helper is fine with unordered lists! */
    }
    fclose(fp);
    return 0;  /* OK */
}

void
ieeeP1451TimTable_free( netsnmp_cache *cache, void *vmagic ) {
    struct ieeeP1451TimTable_entry *this, *that;

    for ( this = ieeeP1451TimTable_head; this; this=that ) {
        that = this->next;
        SNMP_FREE( this );   /* XXX - release any other internal resources */
    }
    ieeeP1451TimTable_head = NULL;
}

/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
ieeeP1451TimTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = ieeeP1451TimTable_head;
    return ieeeP1451TimTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
ieeeP1451TimTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct ieeeP1451TimTable_entry *entry = (struct ieeeP1451TimTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->timID );
        idx = idx->next_variable;
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->channelID );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the ieeeP1451TimTable table */
int
ieeeP1451TimTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct ieeeP1451TimTable_entry          *table_entry;
    struct ieeeP1451TimTable_entry          *table_row;
    int ret;

    DEBUGMSGTL(("ieeeP1451Project:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451TimTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_TIMID:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->timID);
                break;
            case COLUMN_CHANNELID:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->channelID);
                break;
            case COLUMN_COMMUTYPE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->commuType,
                                          table_entry->commuType_len);
                break;
            case COLUMN_COMMUADDRESS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->commuAddress,
                                          table_entry->commuAddress_len);
                break;
            case COLUMN_TESTVALUE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->testValue,
                                          table_entry->testValue_len);
                break;
            case COLUMN_P1451ROWSTATUS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->p1451RowStatus);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451TimTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_TIMID:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CHANNELID:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_COMMUTYPE:
	        /* or possibly 'netsnmp_check_vb_type_and_size' */
                ret = netsnmp_check_vb_type_and_max_size(
                          request->requestvb, ASN_OCTET_STR, sizeof(table_entry->commuType));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_COMMUADDRESS:
	        /* or possibly 'netsnmp_check_vb_type_and_size' */
                ret = netsnmp_check_vb_type_and_max_size(
                          request->requestvb, ASN_OCTET_STR, sizeof(table_entry->commuAddress));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_TESTVALUE:
	        /* or possibly 'netsnmp_check_vb_type_and_size' */
                ret = netsnmp_check_vb_type_and_max_size(
                          request->requestvb, ASN_OCTET_STR, sizeof(table_entry->testValue));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_P1451ROWSTATUS:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error( reqinfo, request,
                                           SNMP_ERR_NOTWRITABLE );
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451TimTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_TIMID:
            case COLUMN_CHANNELID:
            case COLUMN_COMMUTYPE:
            case COLUMN_COMMUADDRESS:
            case COLUMN_TESTVALUE:
            case COLUMN_P1451ROWSTATUS:
                if ( !table_row ) {
                    table_row = ieeeP1451TimTable_createEntry(
                         *table_info->indexes->val.integer
                        , *table_info->indexes->next_variable->val.integer
                        );
                    if (table_row) {
                        netsnmp_insert_iterator_context( request, table_row );
                    } else {
                        netsnmp_set_request_error( reqinfo, request,
                                                   SNMP_ERR_RESOURCEUNAVAILABLE );
                        return SNMP_ERR_NOERROR;
                    }
                }
                break;
            }
        }
        break;

    case MODE_SET_FREE:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451TimTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_TIMID:
            case COLUMN_CHANNELID:
            case COLUMN_COMMUTYPE:
            case COLUMN_COMMUADDRESS:
            case COLUMN_TESTVALUE:
            case COLUMN_P1451ROWSTATUS:
                if ( table_entry && !table_entry->valid ) {
                    ieeeP1451TimTable_removeEntry(table_row );
                }
                break;
            }
        }
        break;

    case MODE_SET_ACTION:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451TimTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_TIMID:
                table_entry->old_timID = table_entry->timID;
                table_entry->timID     = *request->requestvb->val.integer;
                break;
            case COLUMN_CHANNELID:
                table_entry->old_channelID = table_entry->channelID;
                table_entry->channelID     = *request->requestvb->val.integer;
                break;
            case COLUMN_COMMUTYPE:
                memcpy( table_entry->old_commuType,
                        table_entry->commuType,
                        sizeof(table_entry->commuType));
                table_entry->old_commuType_len =
                        table_entry->commuType_len;
                memset( table_entry->commuType, 0,
                        sizeof(table_entry->commuType));
                memcpy( table_entry->commuType,
                        request->requestvb->val.string,
                        request->requestvb->val_len);
                table_entry->commuType_len =
                        request->requestvb->val_len;
                break;
            case COLUMN_COMMUADDRESS:
                memcpy( table_entry->old_commuAddress,
                        table_entry->commuAddress,
                        sizeof(table_entry->commuAddress));
                table_entry->old_commuAddress_len =
                        table_entry->commuAddress_len;
                memset( table_entry->commuAddress, 0,
                        sizeof(table_entry->commuAddress));
                memcpy( table_entry->commuAddress,
                        request->requestvb->val.string,
                        request->requestvb->val_len);
                table_entry->commuAddress_len =
                        request->requestvb->val_len;
                break;
            case COLUMN_TESTVALUE:
                memcpy( table_entry->old_testValue,
                        table_entry->testValue,
                        sizeof(table_entry->testValue));
                table_entry->old_testValue_len =
                        table_entry->testValue_len;
                memset( table_entry->testValue, 0,
                        sizeof(table_entry->testValue));
                memcpy( table_entry->testValue,
                        request->requestvb->val.string,
                        request->requestvb->val_len);
                table_entry->testValue_len =
                        request->requestvb->val_len;
                break;
            case COLUMN_P1451ROWSTATUS:
                table_entry->old_p1451RowStatus = table_entry->p1451RowStatus;
                table_entry->p1451RowStatus     = *request->requestvb->val.integer;
                break;
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451TimTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_TIMID:
                if ( table_entry && !table_entry->valid ) {
                    ieeeP1451TimTable_removeEntry( table_row );
                } else {
                    table_entry->timID     = table_entry->old_timID;
                    table_entry->old_timID = 0;
                }
                break;
            case COLUMN_CHANNELID:
                if ( table_entry && !table_entry->valid ) {
                    ieeeP1451TimTable_removeEntry(table_row );
                } else {
                    table_entry->channelID     = table_entry->old_channelID;
                    table_entry->old_channelID = 0;
                }
                break;
            case COLUMN_COMMUTYPE:
                if ( table_entry && !table_entry->valid ) {
                    ieeeP1451TimTable_removeEntry( table_row );
                } else {
                    memcpy( table_entry->commuType,
                            table_entry->old_commuType,
                            sizeof(table_entry->commuType));
                    memset( table_entry->old_commuType, 0,
                            sizeof(table_entry->commuType));
                    table_entry->commuType_len =
                            table_entry->old_commuType_len;
                }
                break;
            case COLUMN_COMMUADDRESS:
                if ( table_entry && !table_entry->valid ) {
                    ieeeP1451TimTable_removeEntry( table_row );
                } else {
                    memcpy( table_entry->commuAddress,
                            table_entry->old_commuAddress,
                            sizeof(table_entry->commuAddress));
                    memset( table_entry->old_commuAddress, 0,
                            sizeof(table_entry->commuAddress));
                    table_entry->commuAddress_len =
                            table_entry->old_commuAddress_len;
                }
                break;
            case COLUMN_TESTVALUE:
                if ( table_entry && !table_entry->valid ) {
                    ieeeP1451TimTable_removeEntry( table_row );
                } else {
                    memcpy( table_entry->testValue,
                            table_entry->old_testValue,
                            sizeof(table_entry->testValue));
                    memset( table_entry->old_testValue, 0,
                            sizeof(table_entry->testValue));
                    table_entry->testValue_len =
                            table_entry->old_testValue_len;
                }
                break;
            case COLUMN_P1451ROWSTATUS:
                if ( table_entry && !table_entry->valid ) {
                    ieeeP1451TimTable_removeEntry( table_row );
                } else {
                    table_entry->p1451RowStatus     = table_entry->old_p1451RowStatus;
                    table_entry->old_p1451RowStatus = 0;
                }
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieeeP1451TimTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_TIMID:
            case COLUMN_CHANNELID:
            case COLUMN_COMMUTYPE:
            case COLUMN_COMMUADDRESS:
            case COLUMN_TESTVALUE:
            case COLUMN_P1451ROWSTATUS:
                if ( table_entry && !table_entry->valid ) {
                    table_entry->valid = 1;
                }
            }
        }
        break;
    }
    return SNMP_ERR_NOERROR;
}
